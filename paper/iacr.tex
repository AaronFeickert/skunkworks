\documentclass{llncs}
\pagestyle{headings}

\usepackage{enumerate}
\usepackage{amsmath,amssymb}

\title{Concise Linkable Ring Signatures and Forgery Against Adversarial Keys}
\institute{Monero Research Lab, \email{\{surae,sarang\}@getmonero.org} \and Independent researcher, \email{randomrun@protonmail.com}}
\author{Brandon Goodell\inst{1} \and Sarang Noether\inst{1} \and Arthur Blue\inst{2}}

\begin{document}
\maketitle

\begin{abstract}
We demonstrate that a version of non-slanderability is a natural definition of unforgeability for linkable ring signatures. We present a linkable ring signature construction with concise signatures and multi-dimensional keys that is linkably anonymous if a variation of the decisional Diffie-Hellman problem with random oracles is hard, linkable if key aggregation is a one-way function, and non-slanderable if a one-more variation of the discrete logarithm problem is hard. We remark on some applications in signer-ambiguous confidential transaction models without trusted setup.
\end{abstract}


\section{Introduction}

First introduced in \cite{rivest} in the RSA setting and in \cite{liu2004linkable} in the discrete logarithm setting, ring signatures permit message signing on behalf of a set of public keys rather than a single public key. Ring signatures see myriad applications ranging from lightweight anonymous authentication in \cite{yang2015lightweight} to transaction protocols like Monero in \cite{noether2016ring} and CryptoNote in \cite{van2013cryptonote}. A verifier is assured that the signer knows the private key of at least one of these public keys, which are called ring members. Ring signatures are anonymous or signer-ambiguous in the sense that the verifier does not learn information from the signature about which key is the signer. We stress that methods of practical analysis such as those of  \cite{moser2018empirical,quesnelle2017linkability} can exploit metadata in real-life applications of anonymous authentication protocols to reduce anonymity.

Group signature constructions preceding \cite{rivest,liu2004linkable} require some degree of interactivity, a fixed set of participants, a trusted group manager or other trusted setup, or hardness assumptions not based on the discrete logarithm problem. Since \cite{rivest}, ring signatures have enjoyed many improvements, extensions, and modifications. For example, ring signatures are constructed in the bilinear pairing setting in \cite{zhang2002id}, key structures are generalized in \cite{abe20021}, security definitions are improved in \cite{bender2006ring}, signature size is improved in \cite{fujisaki2011sub,gu2018constant}, and traceability is introduced in \cite{fujisaki2007traceable}.

Linkable ring signature (LRS) constructions were first introduced in \cite{liu2004linkable}; in the context of transaction protocols, linkable ring signatures are the basis for anonymous transaction authentication. Linkable ring signatures guarantee that two signatures with the same ring on arbitrary messages can be publicly linked if signed using the same key. An implementation is presented in \cite{liu2004linkable} in the discrete logarithm setting; that implementation functions for similar reasons as Schnorr signatures in \cite{schnorr1991efficient}.

The signature linking tags in \cite{liu2004linkable} are unsuitable for applications where signatures must be linked key-by-key, not ring-by-ring (such as for ``double-signing'' protection in a setting where users generate new keys over time and select \textit{ad hoc} ring members). Resistance to double-signing attempts is ensured using linking tags as described in \cite{van2013cryptonote} (therein called key images). More recent work of \cite{noether2016ring} extends the approach of \cite{liu2004linkable} to enable an anonymous confidential transaction model with \textit{ad hoc} ring member selection. In \cite{noether2016ring}, transaction amounts are replaced with Pedersen commitments to amounts together with range proofs. Signatures are constructed from key vectors including differences of amount commitments as one of the keys. However, the proofs in \cite{noether2016ring} are informal and not based on rigorous security models.

Alternatives to ring signatures like more general zero-knowledge proving systems typically require a trusted party to honestly perform a setup process (as in \cite{groth,ben2014succinct,groth2018updatable}) or lack practical efficiency for large circuits (as in \cite{bulletproofs}), meaning that such systems may not be appropriate for distributed ledger applications. However, more recent approaches such as \cite{hoffmann2019efficient} show both improvements to the trust requirement as well as improvements in efficiency.

Definitions of existential unforgeability for ring signature schemes from \cite{bender2006ring} are generally inappropriate for LRS. These definitions ensure that forgeries appear to be computed from uncorrupted challenge keys by restricting choices of anonymity set members and oracle queries. We can do better with linkability.

The idea of existential unforgeability in usual digital signatures is to task an algorithm to produce any valid, non-oracle signature on any message such that the signature appears to be signed by an uncorrupted challenge key. The clear analogue for LRS schemes is to task an algorithm to produce any valid, non-oracle signature on any message such that the signature links to a challenge signature computed from an uncorrupted challenge key.  Contrast this intuition with the definition of unforgeability for usual ring signatures with respect to insider corruption from \cite{bender2006ring}, which does not count a valid signature $\sigma$ with an anonymity set $Q$ as a forgery if any key in $Q$ is corrupt or not a challenge key, or a signing oracle has been queried with the same anonymity set $Q$ and message. This leads to two problems.

The first problem is due to the disqualification of a purported forgery if there are any adversarially-selected keys or corrupted challenge keys in the anonymity set. Such a signature that links with an uncorrupted challenge key does not count as a forgery. In ring signature schemes without linkability, this restriction seems requisite to ensure that the signature appears to be signed by an uncorrupted challenge key. In applications like signer-ambiguous transaction protocols that use anonymity sets selected \textit{ad hoc}, anonymity set members should be assumed to be adversarially generated. Definitions of unforgeability should take this into account.

The second problem is due to the signing oracle restriction in this definition. An adversary could generate a valid, non-oracle signature re-using the same message and anonymity set as some challenge signature generated by the oracle. A verifier who has found more than one valid non-oracle signature on the same message with the same anonymity set, under this definition, can only conclude that at least one anonymity set member signed at least one of the signatures. This allows a malicious Mallory-in-the-middle to collect outgoing honest signatures on some honest messages and attempt to construct clone signatures on these honest messages. A sender attempting to assert culpability over a signature could then be in danger of being unable to reconstruct a signature sent to some receiver.

These problems seem to interfere with the spirit behind existential unforgeability with insider corruption from \cite{bender2006ring}: the signature is valid, not produced by an oracle, appears to have been computed from an uncorrupted challenge key, and yet is not considered a forgery.


\subsection{Our Contribution}

We relax the notion of successful forgeries to require only linking with uncorrupted challenge keys, obtaining a notion of unforgeability for linkable ring signatures that is equivalent to the definition of non-slanderability in \cite{au2006short}.  Non-slanderability allows for adversaries who can query a signature oracle with any anonymity set, even adversarially-selected anonymity sets. This models an extremely persuasive adversary who can convince users to sign messages with adversarially-selected anonymity sets. We show that non-slanderability implies unforgeability with respect to insider corruption from \cite{bender2006ring}.

We also present a Schnorr-like linkable ring signature scheme we call $d$-CLSAG that exploits key aggregation techniques to improve signature size. We describe an application for the $d$-CLSAG scheme in ring confidential transaction protocols, allowing transactions consisting of $d-1$ distinct assets simultaneously. We prove that $d$-CLSAG is linkable assuming collision resistance in key aggregation and linkably anonymous assuming the decisional Diffie-Hellman game is hard. Recall that Schnorr-like signature schemes do not cleanly reduce to the discrete logarithm assumption (\textit{c.f.}\ \cite{paillier2005discrete}), generally are only secure up to the (relatively flimsier) one-more hardness assumptions, and proof techniques typically exploit programmable random oracles with forking lemmata, leading to weak bounds. We use the general forking lemma to prove that $d$-CLSAG is non-slanderable assuming a $\kappa$-one-more variation of the discrete logarithm game is hard.


\section{Preliminaries}

Let $\lambda$ be a security parameter and $1 \leq q, \eta, \kappa \in poly(\lambda)$. Let $\mathbb{G} = \langle G \rangle$ denote a group over a field $\mathbb{F}$ with generator $G$.  Let $\mathcal{H}^s:\left\{0,1\right\}^* \to \mathbb{F}$ and $\mathcal{H}^p:\left\{0,1\right\}^* \to \mathbb{G}$ be two independent cryptographic hash functions under the random oracle model, \textit{i.e.}\ sampled uniformly from the set of all functions $\left\{0,1\right\}^* \to \mathbb{F}$ and $\left\{0,1\right\}^* \to \mathbb{G}$, respectively.

If there exists a function $f$ that is negligible in some parameter $\lambda$, and there exists $\lambda$-dependent events $A, B$ such that $\left|\mathbb{P}\left[A\right] - \mathbb{P}\left[B\right]\right| \leq f(\lambda)$, we denote this $\mathbb{P}\left[A\right] \approx \mathbb{P}\left[B\right]$. An event $A$ such that $\mathbb{P}\left[A\right] \approx 0$ is said to be negligible in $\lambda$ (or to occur with probability at most negligible in $\lambda$). The complement of an event $A$ is denoted $\overline{A}$. For a field $\mathbb{F}$, we denote the non-zero elements $\mathbb{F}^* := \mathbb{F}\setminus \left\{0\right\}$. For a finite set $S$, we define $S^*$ by interpreting $S$ as a list of letters that generate the free monoid $S^*$. For example, $\left\{0,1\right\}^*$ consists of all finite-length bitstrings.

For a set $S$, we define $\mathcal{P}(S)$ as the power set of $S$, i.e.\ the set of all subsets of $S$.

We denote vectors with bold, i.e.\ for a sequence $x_i \in \mathbb{F}$ for $i = 0, \ldots, n-1$, we denote the tuple $(x_0, \ldots, x_{n-1})$ with $\textbf{x}$. We denote the Hadamard product between vectors with $\textbf{x} \circ \textbf{y} = (x_i y_i)_i$. We begin all indices at $0$ to avoid all ambiguity.


\section{Definitions}

\subsection{Hardness Assumptions}\label{sec:hardness}

We begin by noting that if $\left\{\mu_i\right\}_{i=0}^{d-1} \subseteq \mathbb{F}$ are selected uniformly at random, then the function $\mu: \mathbb{F}^d \to \mathbb{F}$ defined by mapping $\textbf{x} \mapsto \sum_i \mu_i x_i$ has uniformly distributed output and is collision resistant. We use this property when considering linkability and linkable anonymity.

The following game is equivalent\footnote{A usual $\kappa$-one-more discrete logarithm solver can succeed at the game in Definition \ref{def:komdl} with the same probability and some extra time by merely summing solutions. A solver of the game in Definition \ref{def:komdl} can use their discrete logarithm knowledge to solve for an otherwise uncorrupted challenge key with the same probability and some extra time.} to the usual $\kappa$-one-more discrete logarithm game under the random oracle model.

\begin{definition}[$\kappa$-One-More Linear Combination Discrete Logarithm]\label{def:komdl}

Let $\kappa \geq 1$. We say any PPT algorithm $\texttt{A}$ that can succeed at the following game in time at most $t$ and with success probability at least $\epsilon$ is a $(t, \epsilon, q)$-solver of the $\kappa$-one-more discrete logarithm of linear combinations problem in $\mathbb{G}$.
\begin{enumerate}
\item Challenger draws $\left\{sk_i\right\}_{i=0}^{q-1} \subseteq \mathbb{F}$ at random, computes $pk_i := sk_i \cdot G$, sends $S := \left\{pk_i\right\}_{i=0}^{q-1}$ to $\texttt{A}$.

\item $\texttt{A}$ is granted access to a corruption oracle $\texttt{CO}$ which takes as input a public key $pk_i \in S$ and produces as output the corresponding private key $sk_i$. Corrupted keys are recorded in a table $C$.

\item $\texttt{A}$ outputs some $w \in \mathbb{F}\setminus \left\{0\right\}$, a sequence of field elements $\left\{h_j\right\}_{j=0}^{\kappa} \subseteq \mathbb{F} \setminus \left\{0\right\}$, and a subset of challenge keys $\left\{pk^*_j\right\}_{j=0}^{\kappa} \subseteq \left\{pk_i\right\}_{i=0}^{q-1}$, succeeding if and only if $w \cdot G = \sum_{j=0}^{\kappa} h_j \cdot pk^*_j$ and
 $\texttt{A}$ queried $\texttt{CO}$ no more than $\kappa$ times.

\end{enumerate}
We say that the discrete logarithms of linear combinations are computationally hard to compute in $\mathbb{G}$ if any $(t, \epsilon, q)$-solver of this game has an advantage  that is $\epsilon$ negligible in $q$.
\end{definition}

For an algorithm $\texttt{A}$ that takes as input a random tape $\rho$, a sequence of random oracle queries $\textbf{h}$ and some input $inp$ and produces $(out, idx) \leftarrow \texttt{A}(\rho, \textbf{h}, inp)$ as output, the general forking algorithm works as follows.

\begin{enumerate}[(1)]
\item  Pick a random tape $\rho$ for $\texttt{A}$ and two sequences of random oracle queries $\textbf{h} = \left\{h_0, h_1, \ldots\right\}$ and $\textbf{h}^\prime = \left\{h_0^\prime, h_1^\prime, \ldots\right\}$.

\item Execute $(out, idx) \leftarrow \texttt{A}(\rho, \textbf{h}, inp)$.

\item Set $j := idx$ and glue the oracle queries $\textbf{h}$, $\textbf{h}^\prime$ together \[\textbf{h}^* = \left\{h_0, h_1, \ldots, h_{idx - 1}, h_{idx}^\prime, h_{idx+1}^\prime, \ldots, \right\}.\]

\item Execute $(out^*, idx^*) \leftarrow \texttt{A}(\rho, \textbf{h}^*, inp)$.

\item If $idx \neq idx^*$ or $h_{idx} = h_{idx}^\prime$, output $\bot$ and terminate. Otherwise, output $(out, out^\prime, idx)$.
\end{enumerate}

This algorithm is precisely the algorithm $\mathcal{F}^{\texttt{A}}$ in the following lemma.

\begin{lemma}[General Forking Lemma]\label{lem:fork}
Let $1 \leq \eta \in \text{poly}(\lambda)$. Let $\texttt{A}$ be any PPT algorithm which takes as input some tuple $x_\texttt{A} = (x, \textbf{h})$ where we let $\textbf{h} = (h_0, h_1, \ldots, h_{q-1})$ be a sequence of oracle query responses ($\eta$-bit strings) and returns as output $y_{\texttt{A}}$ either a distinguished failure symbol $\bot$ or a pair $(\textit{idx}, y)$ where $\text{idx} \in [q]^2$ and $y$ is some output. Let $\epsilon_{\texttt{A}}$ denote the probability that $\texttt{A}$ does not output $\bot_{\texttt{A}}$ (where this probability is taken over all random coins of $\texttt{A}$, the distribution of $x$, and all choices $\textbf{h}$). Let $\mathcal{F} = \mathcal{F}^{\texttt{A}}$ be a forking algorithm for $\texttt{A}$. The accepting probability of $\mathcal{F}$ satisfies $\epsilon_{\mathcal{F}} \geq \epsilon_{\texttt{A}} \left(\frac{\epsilon_{\texttt{A}}}{q} - \frac{1}{2^\eta}\right)$.
\end{lemma}

We assume that the following game, under the random oracle model, is as hard as the usual (fixed-base) decisional Diffie-Hellman game.

\begin{definition}[Random Oracle Decisional Diffie-Hellman]\label{def:rom-ddh}

We say any PPT algorithm $\texttt{A}$ that can succeed at the following game in time at most $t$ and with success probability at least $\epsilon$ is a $(t, \epsilon, q)$-solver of the random oracle decisional Diffie-Hellman game.
\begin{enumerate}
\item Challenger draws $\left\{sk_i\right\}_{i=0}^{q-1} \subseteq \mathbb{F}$ at random, computes $pk_i := sk_i \cdot G$, computes group elements $\mathfrak{T}^{(1)}_i := sk_i \cdot \mathcal{H}^p(pk_i)$, samples random group elements $\left\{\mathfrak{T}^{(0)}_i\right\}_{i=0}^{q-1} \subseteq \mathbb{G}$, computes $S^{(j)} := \left\{(pk_i, \mathfrak{T}^{(j)}_i)\right\}_{i=0}^{q-1}$ for $j \in \{0,1\}$, samples a random bit $b$, sends $S^{(b)}$ to $\texttt{A}$, and lastly grants $\mathcal{H}^p$ access to $\texttt{A}$.

\item $\texttt{A}$ outputs a bit $b^\prime$, succeeding if and only if $b = b^\prime$.
\end{enumerate}

We say random oracle Diffie-Hellman points are hard to computationally distinguish from random in $\mathbb{G}$ if any $(t, \epsilon, q)$-solver of the random oracle decisional Diffie-Hellman game has an advantage $\left|\epsilon - 1/2\right|$ that is negligible in $q$, where this probability is measured over all functions $\mathcal{H}^p$.
\end{definition}


\subsection{Linkable Ring Signatures}

\begin{definition}\label{def:lrs} A linkable ring signature (LRS) scheme $\Pi_{LRS}$ is a tuple of algorithms $(\texttt{SETUP}, \texttt{KEYGEN}, \texttt{SIGN}, \texttt{VERIFY}, \texttt{LINK})$ satisfying the following constraints.
\begin{itemize}
\item $\texttt{SETUP}$ takes as input a security parameter $\lambda$ and produces as output some public setup parameters $\rho$.

\item $\texttt{KEYGEN}$ takes as input $(\lambda, \rho)$ and outputs a private-public keypair $(sk, pk)$.

\item $\texttt{SIGN}$ takes as input $(\lambda, \rho)$ and a triple $(m, Q, sk)$ and outputs a signature $\sigma$ or a failure symbol $\bot$. Here $m$ is a message, $Q$ is an anonymity set of public keys $Q = \left\{pk_0, pk_1, ..., pk_{n-1}\right\}$, and $sk$ is a private key.

\item $\texttt{VERIFY}$ takes as input $(\lambda, \rho)$ and a triple $(m, Q, \sigma)$ and outputs a bit $b$. Here $m$ is a message, $Q$ is an anonymity set of public keys $Q = \left\{pk_0, pk_1, ..., pk_{n-1}\right\}$, and $\sigma$ is a signature.

\item $\texttt{LINK}$ takes as input $(\lambda, \rho)$, a pair of triples $(m, Q, \sigma)$, $(m^*, Q^*, \sigma^*)$, and outputs a bit $b$. Here $m, m^*$ are messages, $Q, Q^*$ are anonymity sets of public keys, and $\sigma, \sigma^*$ are signatures.
\end{itemize}
We say a triple of the form $(m, Q, \sigma)$ (that is to say, a triple suitable for use as input in $\texttt{VERIFY}$ and $\texttt{LINK}$) is a \textit{signature triple}. We say $\Pi_{LRS}$ is a $d$-LRS if the dimension of private and public keys is $d \geq 1$ and anonymity sets can be described as $d\times n$ matrices.
\end{definition}

We assume $\rho$ includes (implicitly or explicitly) descriptions of a private key space $\mathcal{SK}$, a public key space $\mathcal{PK}$, a signature space $\mathcal{SIG}$, a map $\phi: \mathcal{SK} \to \mathcal{PK}$, and a family of hash functions $\mathcal{H}$ from which we can construct $\mathcal{H}^s$ and $\mathcal{H}^p$. For example, with an elliptic curve group $\mathbb{G}$ over a field $\mathbb{F}$, for two hash functions $H_s:\left\{0,1\right\}^* \to \mathbb{F}$ and $H_p:\left\{0,1\right\}^* \to \mathbb{G}$, a Schnorr-like ring signature scheme such as \cite{liu2004linkable} would pack into $\rho$ the descriptions $\mathcal{SK} = \mathbb{F}^*$, $\mathcal{PK} = \mathbb{G}$, $\mathcal{SIG} = \mathbb{F}^n$, and a generator $G \in \mathbb{G}$ (which is sufficient to specify the map $\phi: \mathbb{F}^* \to \mathbb{G}$ defined by $x \mapsto xG$).  Note each algorithm in an LRS scheme takes $(\lambda, \rho)$ as input; in the sequel we exclude these from notation for LRS schemes, taking their use as implicit.

Note we do not allow a LRS scheme to be correct if the scheme allows anonymity multisets $Q$.

\begin{definition}\label{def:lrs-correct}
Let $b\in \left\{0,1\right\}$, $sk, sk^* \in \mathcal{SK}$, let $Q$, $Q^* \subset \mathcal{PK}$ be sets, let $m, m^*, m^\prime$ be messages, let $\sigma, \sigma^*, \sigma^\prime \in \mathcal{SIG}$ be any purported signatures. Define the following events.
\begin{itemize}
\item $E_1(sk, pk)$ is the event that some $(sk, pk) \leftarrow \texttt{KEYGEN}$.

\item $E_2(sk, Q)$ is the event that $\phi(sk) \in Q$.

\item $E_3(m, Q, \sigma)$ is the event that $\texttt{VERIFY}(m, Q, \sigma) = 1$.

\item $E_4(b, m, m^*, m^\prime, Q, Q^*, Q^\prime, \sigma, \sigma^*, \sigma^\prime)$ is the event that \[b = \texttt{LINK}((m, Q, \sigma), (m^*, Q^*, \sigma^*)) = \texttt{LINK}((m^*, Q^*, \sigma^*), (m^\prime, Q^\prime, \sigma^\prime)).\]

\item $E_5(m, m^*, Q, Q^*, \sigma, \sigma^*, sk)$ is the event that \[\phi(sk) \in Q \cap Q^*\text{, }\sigma \leftarrow \texttt{SIGN}(m, Q, sk)\text{, and }\sigma^* \leftarrow \texttt{SIGN}(m^*, Q^*, sk).\]

\item $E_6(m, m^*, Q, Q^*, \sigma, \sigma^*, sk, sk^*)$ is the event that  \[\sigma \leftarrow \texttt{SIGN}(m, Q, sk)\text{, }\sigma^* \leftarrow \texttt{SIGN}(m^*, Q^*, sk^*)\text{, and }sk \neq sk^*.\]
\end{itemize}
We say $\Pi_{LRS}$ is correct if all of the following properties hold, where these probabilities are computed over all random coins and over all choices of hash function.

\begin{enumerate}[(i)]
\item $\mathbb{P}\left[ \phi(sk) = pk \mid E_1(sk, pk) \right] \approx 1$

\item $\mathbb{P}\left[ \texttt{SIGN}(m, Q, sk) = \bot \mid \overline{E_2}(sk, Q)  \right] \approx 1$

\item $\mathbb{P}\left[ \texttt{VERIFY}(m, Q, \texttt{SIGN}(m, Q, sk)) = 1 \mid E_2(sk, Q) \right] \approx 1$

\item $\mathbb{P}\left[\texttt{LINK}((m, Q, \sigma), (m, Q, \sigma)) = 1 \mid E_3(m, Q, \sigma)\right] \approx 1$

\item ${\small \mathbb{P}\left[\texttt{LINK}((m, Q, \sigma), (m^*, Q^*, \sigma^*)) = \texttt{LINK}((m^*, Q^*, \sigma^*), (m, Q, \sigma))\right] \approx 1}$

\item ${\small \mathbb{P}\left[b = \texttt{LINK}((m, Q, \sigma), (m^\prime, Q^\prime, \sigma^\prime)) \mid E_4(b, m, m^*, m^\prime, Q, Q^*, Q^\prime, \sigma, \sigma^*, \sigma^\prime)\right] \approx 1}$

\item $\mathbb{P}\left[ \texttt{LINK}((m, Q, \sigma), (m^*, Q^*, \sigma^*)) = 1 \mid E_5(m, m^*, Q, Q^*, \sigma, \sigma^*, sk) \right] \approx 1$

\item ${\small \mathbb{P}\left[ \texttt{LINK}((m, Q, \sigma), (m^*, Q^*, \sigma^*)) = 0 \mid E_6(m, m^*, Q, Q^*, \sigma, \sigma^*, sk, sk^*) \right] \approx 1}$
\end{enumerate}
\end{definition}


\subsection{Linkability}

We use two distinct, but related, definitions of linkability. The first is from \cite{au2006short}. This definition allows signing oracle queries with any anonymity sets $Q$ consisting of at least one challenge key (which can be simulated via backpatching). This definition also allows the challenger to succeed at the linkability game using signature triples $(m, Q, \sigma)$, $(m^*, Q^*, \sigma^*)$ that have semi-corrupted anonymity sets $Q, Q^*$ (just so long as the keys in $Q \cup Q^*$ have not been tampered with too severely). The second is from \cite{backes2019ring}, which allows the adversary total control over key selection, declaring success when they produce more unlinked ring signatures than total ring members. Such an adversary doesn't need key generation, corruption, or signature oracle access.

\begin{definition}[ACST Linkability With an Adversarial Key]\label{def:acst-link-adv}
We say any PPT algorithm $\texttt{A}$ that can succeed at the following game in time at most $t$ and with success probability at least $\epsilon$ is a $(t, \epsilon, q)$-solver of ACST linkability.

\begin{enumerate}
\item Challenger draws $\left\{(sk_i, pk_i)\right\}_{i=0}^{q-1}$ from $\texttt{KEYGEN}$ and sends the challenge public keys $S = \left\{pk_i\right\}_{i=0}^{q-1}$ to $\texttt{A}$.

\item $\texttt{A}$ is granted \texttt{SO} and \texttt{CO} access.
    \begin{itemize}
    \item \texttt{CO} takes as input a public key $pk$. If $pk \in S$, $\texttt{CO}$ outputs the corresponding private key $sk$. Otherwise, $\texttt{CO}$ outputs a failure symbol, $\bot$. Corrupted keys are tracked in a table $C$.

    \item \texttt{SO} operates as follows:
        \begin{enumerate}[(i)]
        \item Takes as input a message $m$, an anonymity set $Q = \left\{pk^\prime_i\right\}_{i=0}^{n-1}$, and an index $l$.

        \item If $0 > l$ or $l \geq n$ or if the $pk^\prime_l \notin S$, \texttt{SO} outputs a failure symbol $\bot$.

        \item Otherwise, there exists some $i$ such that $pk^\prime_l = pk_i \in S$. \texttt{SO} retrieves the private key $sk_i$ and outputs a valid signature triple $(m, Q, \sigma)$ such that $\sigma \leftarrow \texttt{SIGN}(m, Q, sk_i)$.
        \end{enumerate}
    \end{itemize}

\item $\texttt{A}$ outputs a pair of signature triples, $(m, Q, \sigma)$, $(m^*, Q^*, \sigma^*)$, succeeding if and only if all of the following conditions are satisfied.
    \begin{enumerate}[(i)]
        \item $\texttt{VERIFY}(m, Q, \sigma) = \texttt{VERIFY}(m^*, Q^*, \sigma^*) = 1$
        \item $\texttt{LINK}((m, Q, \sigma), (m^*, Q^*, \sigma^*)) = 0$
        \item $\sigma, \sigma^*$ are not output from any $\texttt{SO}$ query.
        \item $\left|(Q \cup Q^* ) \cap (C \cup \overline{S})\right| \leq 1$
    \end{enumerate}
\end{enumerate}
We say that a scheme is \textit{ACST linkable} if every PPT algorithm $\texttt{A}$ that is a $(t, \epsilon, q)$-solver ACST linkability game has a negligible acceptance probability $\epsilon$.
\end{definition}

\begin{definition}[$q$-Pigeonhole Linkability]\label{def:pig-link}
We say any PPT algorithm $\texttt{A}$ that can succeed at outputting $q$ public keys $\left\{pk_i\right\}_{i=0}^{q-1}$ and $q + 1$ valid, unlinked signature triples $\left\{(m_j, Q_j, \sigma_j)\right\}_{j=0}^{q}$ such that $\cup_j Q_j \subseteq \left\{pk_i\right\}_{i=0}^{q-1}$ in time at most $t$ and probability at least $\epsilon$ is a $(t, \epsilon, q)$-solver of pigeonhole linkability. We say that a scheme is $q$-\textit{pigeonhole linkable} if every PPT algorithm $\texttt{A}$ that is a $(t, \epsilon, q)$-solver of $q$-pigeonhole linkability has a negligible acceptance probability $\epsilon$.
\end{definition}

These definitions are distinct. Pigeonhole linkability does not necessarily imply ACST linkability. Indeed, a successful player of the game in Definition \ref{def:acst-link-adv} may only succeed with sufficiently large rings, in which case that player may only be used to succeed at the game of Definition \ref{def:pig-link} for a sufficiently large $q$. Similarly, ACST linkability may not imply pigeonhole linkability. A player of the game in Definition \ref{def:pig-link} that requires knowledge of many private keys may be too corruption-hungry to succeed at Definition \ref{def:acst-link-adv}.

For a scheme that is pigeonhole linkable, Definition \ref{def:pig-link} says nothing about an adversary that can keep signing with one key multiple times to construct new unlinked signatures, just so long as they continue to use different anonymity sets.

For a scheme that is ACST linkable, a user providing honest signatures to an adversary acts like a signature oracle, so the adversary could  attempt to construct a bad/cloned signature that links to some honest one (possibly with adversarially selected ring members), only ever outputting a single signature. Definition \ref{def:acst-link-adv} says nothing about such an attacker. This attacker could stand between Alice and Bob, provide cloned signatures to the Bob ostensibly signed by Alice, fooling him. When Alice eventually contacts Bob without the adversary in the middle, Alice would be unable to assert culpability over the cloned signatures. Bob concludes that $\sigma^*$ and $\sigma$ were signed by the same private key, despite that the adversary does not know the private key that generated $\sigma$.

However, Definition \ref{def:pig-link} implies Definition \ref{def:acst-link-adv} under certain circumstances.  For one (of many) examples, if there exists a $(t, \epsilon, 1)$-solver of the game in Definition \ref{def:acst-link-adv} that produces two signature triples $(m, Q, \sigma)$, $(m^\prime, Q^\prime, \sigma^\prime)$ such that $Q = Q^\prime$ and $\left|Q\right| = 1$, then $\texttt{A}$ succeeds at Definition \ref{def:pig-link}.

A more general look at the relationships between linkability definitions is beyond the scope of this work. Since neither definition is sufficient for our purposes alone and these definitions are distinct in general, we use both.


\subsection{Unforgeability and Non-Slanderability}

The idea of existential unforgeability in usual digital signatures is to task an algorithm to produce any valid, non-oracle signature on any message such that the signature appears to be signed by an uncorrupted challenge key. The clear analogue for LRS schemes is to task an algorithm to produce any valid, non-oracle signature on any message such that the signature links to a challenge signature computed from an uncorrupted challenge key. In fact, the implementation in Section \ref{sec:implementation} compares linking tags as if they were verification keys; in this sense, a forger is tasked to construct a valid signature with some verification keys to which they do not know the corresponding private key. We consider this to be a textbook forgery, and so we take these occurrences into account in our definition.

\begin{definition}[Existential Unforgeability of Linkable Ring Signatures Against Adversarially-Selected Keys and Insider Corruption]\label{def:ex-unf}
We say any PPT algorithm $\texttt{A}$ that can succeed at the following game in time at most $t$ and with probability at least $\epsilon$ is a $(t, \epsilon, q)$-forger.
\begin{enumerate}

\item Challenger draws $\left\{(sk_i, pk_i)\right\}_{i=0}^{q-1}$ from \texttt{KEYGEN} and sets $S := \left\{pk_i\right\}_{i=0}^{q-1}$. For each $0 \leq i < q$, the challenger uniformly samples secret $\emptyset \neq \widetilde{Q}_i \in \mathcal{P}\left(S\right)$, defines $Q_i := \widetilde{Q}_i \cup \left\{pk_i\right\}$, retrieves the index $l_i$ such that $pk_{i} \in Q_i \cap S$ has index $l_i$ in $Q_i$, samples secret random messages $\left\{m_i\right\}_{i=0}^{q-1}$, and computes secret challenge signatures $\sigma_i \leftarrow \texttt{SIGN}(m_i, Q_i, sk_i)$.  Challenger sends $S$ to $\texttt{A}$.
\item Challenger grants \texttt{SO} and \texttt{CO} access to \texttt{A}:
    \begin{itemize}
    \item \texttt{CO} takes as input a challenge public key $pk_i \in S$ and produces as output the corresponding private key $sk_i$, keeping a list of all corrupted public keys in an internal table $C$.

    \item \texttt{SO} operates as follows:
        \begin{enumerate}[(i)]
        \item Takes as input a message $m$, an anonymity set $Q$, and an index $l$.

        \item If the key at index $l$ in $Q$ is not a challenge public key from $S$, \texttt{SO} outputs a failure symbol $\bot$.

        \item Otherwise, \texttt{SO} retrieves the index $i$ such that $pk_{i} \in Q \cap S$ has index $l$ in $Q$, retrieves the corresponding private key $sk_{i}$, and outputs a signature $\sigma \leftarrow \texttt{SIGN}(m, Q, sk_{i})$.
        \end{enumerate}
    \end{itemize}

\item $\texttt{A}$ outputs a message $m$, a ring $Q$, a signature $\sigma$, succeeding if and only if:
    \begin{enumerate}[(i)]
    \item $\texttt{VERIFY}(m, Q, \sigma) = 1$,

    \item there does not exist a query made to $\texttt{SO}$ whose output is $\sigma$,

    \item ${\small \texttt{LINK}((m, Q, \sigma), (m_i, Q_i, \sigma_i)) = 1}$ for some  $pk_i \in S \cap Q \setminus C$.
    \end{enumerate}
\end{enumerate}
Moreover, we say that a linkable ring signature scheme is \textit{unforgeable} if every $(t, \epsilon, q)$-solver of this game has a negligible acceptance probability $\epsilon$.
\end{definition}

\begin{remark}
Access to a corruption oracle in this unforgeability definition is one reason security reduces (weakly) to the $\kappa$-one-more discrete logarithm problem, not the usual discrete logarithm problem: an algorithm executing a forgery algorithm in a black box cannot simulate the corruption oracle for the forgery without, itself, gaining corruption oracle access or without resorting to the generic group model.
\end{remark}

\begin{remark}
If \texttt{A} is an algorithm that produces signatures from an LRS satisfying Definition \ref{def:ex-unf}, then (except with negligible probability), the signatures aren't forgeries, so some property 3(i)-3(iii) must be violated. If the signature is valid and not from an oracle query, then 3(iii) fails. In particular, for an LRS scheme satisfying Definition \ref{def:ex-unf}, if an algorithm produces a valid non-oracle triple $(m, Q, \sigma)$ that links to a challenge key in $Q$, then that challenge key has been corrupted.
\end{remark}

Non-slanderability is introduced in \cite{tsang2004separable}.  This definition is refined twice in \cite{au2006short}, allowing \texttt{A} to succeed whenever it publishes any signature that links with any signature from a query $\texttt{A}$ made to $\texttt{SO}$, excepting certain conditions. We modify the definition from \cite{au2006short} to allow signing oracle queries with anonymity sets containing adversarially selected members.

\begin{definition}[Chosen-Target Non-Slanderability Against Adversarial Keys and Insider Corruption]\label{def:acst-nonsl}
We say any PPT algorithm $\texttt{A}$ that can succeed at the following game in time at most $t$ and with probability at least $\epsilon$ is a $(t, \epsilon, q)$-solver of non-slanderability against adversarially chosen keys.
\begin{enumerate}
\item Challenger draws $\left\{(sk_i, pk_i)\right\}_{i=0}^{q-1}$ from KeyGen and sends the challenge public keys $S = \left\{pk_i\right\}_{i=0}^{q-1}$ to \texttt{A}.

\item A is granted \texttt{SO} and \texttt{CO} access just as in Definition \ref{def:ex-unf}.

\item A outputs a triple $(m, Q, \sigma)$, succeeding if and only if:
    \begin{enumerate}[(i)]
    \item $\texttt{VERIFY}(m, Q, \sigma) = 1$, and

    \item there does not exist a query made to $\texttt{SO}$ whose output is $\sigma$, and

    \item there exists a query made to $\texttt{SO}$, say $\sigma^* \leftarrow \texttt{SO}(m^*, Q^*, l^*)$, such that
        \begin{enumerate}[(a)]
        \item $\texttt{LINK}((m, Q, \sigma), (m^*, Q^*, \sigma^*)) = 1$, and

        \item $pk^*_{l^*} \in S \cap Q^* \cap Q \setminus C$.
        \end{enumerate}
    \end{enumerate}
\end{enumerate}
Moreover, we say that a linkable ring signature scheme is \textit{non-slanderable} if every $(t, \epsilon, q)$-solver of this game has a negligible acceptance probability $\epsilon$.
\end{definition}

\begin{theorem}[Non-Slanderability is Unforgeability]\label{thm:nonsl-implies-unf}
A correct LRS is unforgeable under Definition \ref{def:ex-unf} if and only if it is non-slanderable under Definition \ref{def:acst-nonsl}.
\end{theorem}

\begin{proof}
If $\texttt{A}$ is a $(t, \epsilon, q)$-solver of the game of Definition \ref{def:ex-unf}, then $\texttt{A}$ can always be wrapped in an algorithm that executes $\texttt{A}$ in a black box and regurgitates the results, except querying the signing oracle with the linking challenge key before outputting the results of $\texttt{A}$. Such an algorithm succeeds at the game of Definition \ref{def:acst-nonsl} with exactly equal success probability and asymptotically equal timing as $\texttt{A}$. For the converse, let $\texttt{A}$ be a $(t, \epsilon, q)$-solver of the game of Definition \ref{def:acst-nonsl}. With probability at least $\epsilon$, $\texttt{A}$ outputs a signature triple $(m, Q, \sigma)$ such that the triple is valid and $\sigma$ is not output from any $\texttt{SO}$ query and there exists some query, say $\sigma^* \leftarrow \texttt{SO}(m^*, Q^*, pk^*_{l^*})$ in the transcript between $\texttt{A}$ and $\texttt{SO}$. The challenge key $pk^*_{l^*} = pk_i \in S$ for some $i$ and the signature $\sigma^*$ links with $\sigma$.  By the transitivity of $\texttt{LINK}$, we obtain that $\sigma$ links to $\sigma_i$.
\end{proof}


\subsection{Linkable Anonymity}

We use a modification of the definition of linkable anonymity from \cite{backes2019ring}.

\begin{definition}[Chosen-Target Linkable Anonymity With Adversarial Keys]\label{linkable-anonymity-game}
We say any PPT algorithm $\texttt{A}$ that can succeed at the following game in time at most $t$ and with probability at least $\epsilon$ is a $(t, \epsilon, q)$-solver of the linkable anonymity game.
\begin{enumerate}
\item Challenger samples a secret random bit $b \in \left\{0,1\right\}$, draws $\left\{(sk_i, pk_i)\right\}_{i=0}^{q-1}$ from $\texttt{KEYGEN}$, and sends the challenge public keys $S := \left\{pk_i\right\}_{i=0}^{q-1}$ to $\texttt{A}$.

\item $\texttt{A}$ outputs a pair of indices $0 \leq i_0, i_1 < q$ such that $pk_{i_0}, pk_{i_1} \in S$, indicating the target keys.

\item  $\texttt{A}$ is granted access to a signing oracle $\texttt{SO}$:
    \begin{enumerate}[(i)]
    \item Takes as input a message $m$, an anonymity set $Q$, and a public key $pk \in Q$.

    \item If $\left\{pk_{i_0}, pk_{i_1}\right\} \not\subseteq Q$ or $pk \notin \left\{pk_{i_0}, pk_{i_1}\right\}$, then $\texttt{SO}$ outputs a valid signature $\sigma$ linked to $pk$.

    \item Otherwise, $pk = pk_{i_c}$ for a bit $c$. The bit $c^\prime = (1-c)b + c(1-b)$ is computed and the oracle outputs $\sigma \leftarrow \texttt{Sign}(m, Q, sk_{i_{c^\prime}})$.
    \end{enumerate}

\item $\texttt{A}$ outputs a bit $b^\prime$, succeeding if $b^\prime = b$.
\end{enumerate}
Moreover, we say that a scheme is \textit{linkably anonymous} if every $(t, \epsilon, q)$-solver of the linkable anonymity game has a negligible acceptance advantage $\epsilon$ over $1/2$.
\end{definition}


\section{Construction}\label{sec:implementation}

In this section, we describe $d$-CLSAG, our implementation of a concise $d$-LRS construction.

\begin{definition}[$d$-CLSAG]\label{def:clsag}
The tuple $(\texttt{Setup}, \texttt{KeyGen}, \texttt{Sign}, \texttt{Verify}, \allowbreak \texttt{Link})$ as follows is a $d$-LRS signature scheme.

\begin{itemize}
\item $\texttt{Setup} \to \textit{par}$. $\texttt{Setup}$ selects a prime $p$, a group $\mathbb{G}$ with prime order $p$, selects a group generator $G \in \mathbb{G}$ uniformly at random, selects $d$ cryptographic hash functions $\mathcal{H}^s_0, \ldots, \mathcal{H}^s_{d-1}$ with codomain $\mathbb{F}_p$, selects a cryptographic hash function $\mathcal{H}^p$ with codomain $\mathbb{G}$. $\texttt{Setup}$ outputs the group parameter tuple and the hash functions, $\textit{par} := \left(p,\mathbb{G}, d, G, \left\{\mathcal{H}^s_j\right\}_{j=0}^{d-1}, \mathcal{H}^p\right)$.\footnote{Note that domain separation can be used here to take one $\mathcal{H}^s$ and construct each $\mathcal{H}^s_j$ by defining $\mathcal{H}^s_j(x) := \mathcal{H}^s(j \mid\mid x)$.}

\item $\texttt{KeyGen} \to (\textbf{sk}, \textbf{pk})$. When queried for a new key, $\texttt{KeyGen}$ samples a fresh secret key and computes the associated public key:
\begin{align*}
\textbf{sk} =& (z_0, z_1, \ldots, z_{d-1}) \leftarrow (\mathbb{F}_p^*)^d\\
\textbf{pk} :=& \textbf{sk} \circ \textbf{G} = (Z_0, Z_1, \ldots, Z_{d-1}) \in \mathbb{G}^d
\end{align*} where $\textbf{G} = (G, \ldots, G) \in \mathbb{G}^d$. $\texttt{KeyGen}$ outputs $(\textbf{sk}, \textbf{pk})$. We say $z_0$ is the \textit{linking key}, the remaining keys $\left\{z_j\right\}_{j=1}^{d-1}$ are the \textit{auxiliary keys}, and we denote the linking key with $x$.

\item $\texttt{Sign}\left(m, Q, \textbf{sk}\right) \to \left\{\bot_{\texttt{Sign}}, \sigma\right\}$. $\texttt{Sign}$ takes as input a message $m \in \left\{0,1\right\}^*$, a ring  $Q = (\textbf{pk}_0, \ldots, \textbf{pk}_{n-1})$ for ring members $\textbf{pk}_i = (X_i, Z_{i,1}, \ldots, Z_{i,d-1}) \in \mathbb{G}^d$, and a secret key $\textbf{sk} = (x,z_1, \ldots, z_{d-1}) \in (\mathbb{F}_p^*)^d$. $\texttt{Sign}$ does the following.

\begin{enumerate}
\item If $Q \not\subseteq \mathbb{G}^{d\times n}$ for some $n$, $\texttt{Sign}$ outputs $\bot_{\texttt{Sign}}$ and terminates.

\item Otherwise, $\texttt{Sign}$ parses\footnote{Note that this parsing always succeeds if $\texttt{Sign}$ does not fail in the previous step.} $Q$ to obtain each $\textbf{pk}_i$. If the public key associated with the input $\textbf{sk}$ is not a ring member in $Q$, then $\texttt{Sign}$ outputs $\bot_{\texttt{Sign}}$ and terminate.

\item Otherwise, $\texttt{Sign}$ finds the signing index $\ell$ such that $\textbf{pk}_\ell = \textbf{sk} \circ (G, \ldots, G)$. $\texttt{Sign}$ samples $\alpha \in \mathbb{F}_p$, samples $\left\{s_i\right\}_{i \neq \ell} \in (\mathbb{F}_p)^{n-1}$, and computes the points $H_i = \mathcal{H}^p(X_i)$ for each $i$. $\texttt{Sign}$ computes the \textit{aggregation coefficients} $\mu_X$ and $\{\mu_j\}_{j=1}^{d-1}$, the linking tag $\mathfrak{T}$, the auxiliary group elements $\{\mathfrak{D}_j\}_{j=1}^{d-1}$, and the aggregated public keys:
\begin{align*}
\mathfrak{T} :=& x H_\ell & \{\mathfrak{D}_j\} :=&  \{z_j H_\ell\} \\
\mu_X :=& \mathcal{H}^s_0(Q \mid \mid \mathfrak{T} \mid \mid \{\mathfrak{D}_j\}_{j=1}^{d-1})
 & \mu_j :=& \mathcal{H}^s_j(Q \mid \mid \mathfrak{T} \mid \mid \{\mathfrak{D}_j\}_{j=1}^{d-1}) \\
 W_i :=& \mu_X X_i + \sum_{j=1}^{d-1} \mu_j Z_{i,j} & \mathfrak{W} :=& \mu_X \mathfrak{T} + \sum_{j=1}^{d-1} \mu_j \mathfrak{D}_j
 \end{align*} and the aggregated secret key $w_\ell :=  \mu_X x + \sum_{j=1}^{d-1} \mu_j z_j$. For $i = \ell, \ell+1, \ldots, \ell-1$, (and by identifying index $n$ with index $0$), $\texttt{Sign}$ computes
\begin{align*}
L_\ell =& \alpha G & R_\ell =& \alpha H_\ell & c_{\ell+1} =& \mathcal{H}^s_0(Q \mid \mid m \mid \mid L_\ell \mid \mid R_\ell) \\
L_i =& s_i G + c_i W_i & R_i =& s_i H_i + c_i \mathfrak{W}
 & c_{i+1} =& \mathcal{H}^s_0(Q \mid \mid m \mid \mid L_i \mid \mid R_i)
\end{align*} and lastly computes $s_\ell = \alpha - c_\ell w_\ell$.

\item $\texttt{Sign}$ sets the signature $\sigma = (c_0, s_0, s_1, \ldots, s_{n-1}, \mathfrak{T}, \{\mathfrak{D}_j\}_{j=1}^{d-1})$ and publishes the signature $\sigma$.
\end{enumerate}

\item $\texttt{Verify}\left(m, Q, \sigma\right) \to \left\{0,1\right\}$. $\texttt{Verify}$ takes as input a message $m$, a matrix $Q = (\textbf{pk}_0, \ldots, \textbf{pk}_{n-1})$, and a signature $\sigma$.
\begin{enumerate}
\item If $Q \not\subseteq \mathbb{G}^{d \times n}$ for some $n$, or if $\sigma \notin \mathbb{F}_p^{n^\prime+1} \times \mathbb{G}^d$ for some $n^\prime$, $\texttt{Verify}$ outputs $0$ and terminates. Otherwise, if $n^\prime \neq n$, $\texttt{Verify}$ outputs $0$ and terminates.

\item $\texttt{Verify}$ parses\footnote{This parsing is always successful if the previous step does not terminate $\texttt{Verify}$.} $(\textbf{pk}_0, \ldots, \textbf{pk}_{n-1}) \leftarrow Q$ for keys $\textbf{pk}_i \in \mathbb{G}^d$ for $i \in [0,n-1]$, and parses each public key $(X_i, Z_{i, 1}, \ldots, Z_{i, d-1}) \leftarrow \textbf{pk}_i$.  $\texttt{Verify}$ also parses $(c_0, s_0, \ldots, s_{n-1}, \mathfrak{T}, \mathfrak{D}_1, \ldots, \mathfrak{D}_{d - 1}) \leftarrow \sigma$. $\texttt{Verify}$ computes each $H_i = \mathcal{H}^p(X_i)$, computes the aggregation coefficients, and computes aggregated public keys:
\begin{align*}
\mu_X := & \mathcal{H}^s_0(Q \mid \mid \mathfrak{T} \mid \mid \{\mathfrak{D}_j\}_{j=1}^{d-1}) & \mu_j := & \mathcal{H}^s_j(Q \mid \mid \mathfrak{T} \mid \mid \{\mathfrak{D}_j\}_{j=1}^{d-1})\\
W_i :=& \mu_X X_i + \sum_{j=1}^{d-1} \mu_j Z_{i,j} & \mathfrak{W} :=& \mu_X \mathfrak{T} + \sum_{j=1}^{d-1} \mu_j \mathfrak{D}_j
\end{align*}

\item $\texttt{Verify}$ sets $c_0^\prime := c_0$ and, for $i=1, 2, \ldots, n-1$, computes the following.
\begin{align*}
L_i :=& s_i G + c_i^\prime W_i, &
R_i :=& s_i H_i + c_i^\prime\mathfrak{W}, &
c_{i+1}^\prime :=& \mathcal{H}^s_0\left(Q \mid \mid m \mid \mid L_i \mid \mid R_i\right)
\end{align*}
\item If $c_{n}^\prime = c_0$, $\texttt{Verify}$ outputs $1$, and otherwise outputs $0$.
\end{enumerate}

\item $\texttt{Link}\left((m, Q, \sigma), (m^\prime, Q^\prime, \sigma^\prime)\right) \to \left\{0,1\right\}$. $\texttt{Link}$ takes as input two message-ring-signature triples.
\begin{enumerate}
\item If $\texttt{Verify}(m, Q, \sigma) = 0$ or $\texttt{Verify}(m^\prime, Q^\prime, \sigma^\prime) = 0$, $\texttt{Link}$ outputs $0$ and terminates.

\item Otherwise, $\texttt{Link}$ parses\footnote{As before with $\texttt{Verify}$, this parsing is always successful if the previous step does not terminate $\texttt{Link}$.} the signatures to obtain the individual linking tags $(\mathfrak{T}, \left\{\mathfrak{D}_j\right\}_j), (\mathfrak{T}^\prime, \left\{\mathfrak{D}^\prime_j\right\}_j) \leftarrow \sigma, \sigma^\prime$. $\texttt{Link}$ outputs $1$ if $\mathfrak{W} = \mathfrak{W}^\prime$ and $0$ otherwise.
\end{enumerate}
\end{itemize}
\end{definition}

This implementation has \textit{full-key-oriented} linkability with linkability tags $\mathfrak{W}$: two signatures will link if they not only are signed using the same linking and auxiliary keys, but also the same ring. We can replace the $\texttt{Link}$ algorithm with \textit{single-key-oriented} linkability:
\begin{itemize}

\item $\texttt{Link}\left((m, Q, \sigma), (m^\prime, Q^\prime, \sigma^\prime)\right) \to \left\{0,1\right\}$. $\texttt{Link}$ takes as input two message-ring-signature triples.
\begin{enumerate}
\item If $\texttt{Verify}(m, Q, \sigma) = 0$ or $\texttt{Verify}(m^\prime, Q^\prime, \sigma^\prime) = 0$, $\texttt{Link}$ outputs $0$ and terminates.

\item Otherwise, $\texttt{Link}$ parses\footnote{As before with $\texttt{Verify}$, this parsing is always successful if the previous step does not terminate $\texttt{Link}$.} the signatures to obtain the individual linking tags $(\mathfrak{T}, \left\{\mathfrak{D}_j\right\}_j), (\mathfrak{T}^\prime, \left\{\mathfrak{D}^\prime_j\right\}_j) \leftarrow \sigma, \sigma^\prime$. $\texttt{Link}$ outputs $1$ if $\mathfrak{T} = \mathfrak{T}^\prime$ and $0$ otherwise.
\end{enumerate}
\end{itemize}


\section{Proofs of Security}

The following lemma follows immediately from the random oracle model we use for $\mathcal{H}^s$.

\begin{lemma}
For any $Q \subseteq \mathcal{PK}$, for any private key $sk = (x, \left\{z_j\right\}_j) \in Q$, the map $sk \mapsto \mu_X x + \sum_j \mu_j z_j$ where $\mu_X$, $\mu_j$ are computed as in Definition \ref{def:clsag} is a collision-resistant function.
\end{lemma}

We prove $d$-CLSAG is unforgeable in Theorem \ref{thm:nonsl} by showing that if some PPT algorithm produces some valid, non-oracle triple $(m, Q, \sigma)$ that links to an anonymity set member in $Q$ (malicious or otherwise), then that algorithm can be rewound to compute the discrete logarithm of that anonymity set member. This theorem is standard for Schnorr-like signatures in the programmable random oracle model.

\begin{theorem}[Hardness of Discrete Logarithms of Linear Combinations Implies Unforgeability] \label{thm:nonsl}
If a $(t, \epsilon, q)$-solver of the unforgeability exists for the scheme of Definition \ref{def:clsag} that makes $\kappa^\prime$ corruption oracle queries, then there exists a $(2(t+t_0) + t_1, \epsilon\left(\frac{\epsilon}{q} - \frac{1}{2^\eta}\right) - \mu, \lfloor \frac{q}{d}\rfloor)$-solver of the $2d\kappa^\prime$-one-more discrete logarithm of linear combinations problem in $\mathbb{G}$ for some negligible $\mu$ and some constants $t_0, t_1$.
\end{theorem}

\begin{proof}
Assume $\texttt{A}$ is a $(t, \epsilon, q)$-solver of the non-slanderability game of Definition \ref{def:acst-nonsl}. We wrap $\texttt{A}$ in an algorithm $\texttt{B}$. The algorithm $\texttt{B}$ executes $\texttt{A}$ in a black box, handling oracle queries for $\texttt{A}$. Then, $\texttt{B}$ regurgitates the output of $\texttt{A}$ together with an index $idx$. This way, $\texttt{B}$ is suitable for use in the forking lemma. We wrap $\mathcal{F}^{\texttt{B}}$ in a master algorithm $\texttt{M}$ that is a $(2(t+t_0) + t_1, \epsilon\left(\frac{\epsilon}{q} - \frac{1}{2^\eta}\right) - \mu, \lfloor \frac{q}{d}\rfloor)$-solver of the $\kappa$-one-more discrete logarithm of linear combinations problem in $\mathbb{G}$.

If $\texttt{A}$ produces a successful forgery, each verification query of the form $c_{\ell+1} = \mathcal{H}^s(m \mid \mid Q \mid \mid R_\ell \mid \mid L_\ell)$ occurs in the transcript between $\texttt{A}$ and the random oracle $\mathcal{H}^s$. Indeed, the signature triple produced by $\texttt{A}$ passes verification, so each challenge $c_{\ell+1}$, whether made with oracle queries in the transcript or not, must be matched by random oracle queries made by the verifier. The prover cannot guess the output of such a query before making it except with negligible probability. Hence, if $\texttt{A}$ outputs a valid signature, all verification challenges are computed by an actual oracle query. See \cite{liu2004linkable} for a formal proof of this fact. Since all verification challenges are found through genuine oracle queries, which are well-ordered, there exists a first $\mathcal{H}^s$ query made by $\texttt{A}$ for computing verification challenges, say $c = \mathcal{H}^s(m \mid \mid Q \mid \mid R^* \mid \mid L^*)$. This was not necessarily the first query made to $\mathcal{H}^s$ overall, though; say it was the $k^{th}$ query. Although the ring index for this query may not have been decided when this query was first issued by $\texttt{A}$, by the end of the transcript the ring index has been decided.

We construct $\texttt{B}$ in the following way. We grant $\texttt{B}$ access to the same oracles as $\texttt{A}$. Any oracle queries made by $\texttt{A}$ are passed along by $\texttt{B}$ to the oracles. The responses are recorded and then passed back to $\texttt{A}$. The algorithm $\texttt{B}$ works by finding two indices to augment the output of $\texttt{A}$. First, $\texttt{B}$ finds the $\mathcal{H}^s$ query index $k$ corresponding to the first verification challenge computed by $\texttt{A}$ used in verifying the purported foergery. Second, $\texttt{B}$ inspects the transcript of $\texttt{A}$ to find the anonymity set index $\ell$ in the transcript such that $c = c_{\ell+1}$ and $R^* = R_\ell$ and $L^* = L_\ell$. Now $\texttt{B}$ outputs $idx = (k, \ell)$ along with whatever $\texttt{A}$ outputs. Clearly, $\texttt{B}$ makes the same number of corruption oracle queries as $\texttt{A}$.

Note $\texttt{B}$ succeeds whenever $\texttt{A}$ does and runs in time at most $t$ just like $\texttt{A}$, except for some additional time $t_0$ to search the transcript for $idx$.  Since $\texttt{B}$ is suitable for use in the forking lemma, we can use $\mathcal{F}^{\texttt{B}}$ to construct $\texttt{M}$.

The algorithm $\mathcal{F}^{\texttt{B}}$ is granted oracle access to the same oracles as $\texttt{B}$ except $\mathcal{H}^s$ and $\texttt{SO}$. The algorithm $\mathcal{F}^{\texttt{B}}$ simulates $\texttt{SO}$ queries made by $\texttt{B}$ by simple back-patching of $\mathcal{H}^s$ and simulates the other queries made to $\mathcal{H}^s$ queries made by $\texttt{B}$ using the random tapes $\textbf{h}, \textbf{h}^*$ as described in Section \ref{sec:hardness}. All other oracle queries made by $\texttt{B}$ are passed along by $\mathcal{F}^{\texttt{B}}$ to the actual oracles and handed back to $\texttt{B}$.

Note that $\mathcal{F}^{\texttt{B}}$ runs in time $2(t+t_0)$ and (with probability at least $\epsilon\left(\frac{\epsilon}{q} - \frac{1}{2^\eta}\right)$) outputs a pair of valid signature triples $(m, Q, \sigma)$, $(m^\prime, Q^\prime, \sigma^\prime)$. The messages and anonymity sets are selected before the fork point in the transcripts, so $m=m^\prime$ and $Q=Q^\prime$. Moreover, $\mathcal{F}^{\texttt{B}}$ makes at most $2\kappa^\prime$ corruption queries. The challenges for the two transcripts are distinct since the forking algorithm outputs the failure symbol $\bot$ and terminates if the challenges for $c_{\ell + 1}$ are the same in each transcript.
\[c_{\ell + 1} \leftarrow \mathcal{H}^s_0(m \mid \mid Q \mid \mid R_\ell \mid \mid L_\ell) \rightarrow c_{\ell+1}^\prime.\]

We wrap $\mathcal{F}^{\texttt{B}}$ in an algorithm $\texttt{M}$ that plays the $\kappa$-one-more discrete logarithm game of Definition \ref{def:komdl} for $\kappa = 2\cdot d \cdot \kappa^\prime$. The algorithm $\texttt{M}$ has corruption oracle access and runs $\mathcal{F}^{\texttt{B}}$ in a black box, passing corruption oracle queries made by $\mathcal{F}^{\texttt{B}}$ along. The algorithm $\texttt{M}$ finds the following system of equations in the transcripts by inspecting the verification challenge queries
\[R_\ell = s_\ell G + c_\ell X_\ell = s_\ell^\prime G + c_\ell^\prime X_\ell,\]
\[L_\ell = s_\ell H_\ell + c_\ell \mathfrak{W} = s_\ell^\prime H_\ell + c_\ell^\prime \mathfrak{W}.\] This $\texttt{M}$ has enough information to compute
\[ W_\ell = \frac{s_\ell - s_\ell^\prime}{c_\ell^\prime - c_\ell} G,  \mathfrak{W} = \frac{s_\ell - s_\ell^\prime}{c_\ell^\prime - c_\ell} H_\ell.\]
and therefore the private key $w = \frac{s_{\ell} - s_\ell^\prime}{c_\ell^\prime - c_\ell}$. Formally, $\texttt{M}$ operates as follows.

\begin{enumerate}[(1)]
\item $\texttt{M}$ inputs the set of discrete logarithm challenge public keys $S = \left\{\widetilde{pk}_i\right\}_{i=0}^{q-1}$.

\item $\texttt{M}$ partitions the challenge keys into lists of $d$ keys
\begin{align*}
pk_0 =&  (X_0, Z_{0, 1}, \ldots, Z_{0, d-1}) := (\widetilde{pk}_0, \ldots, \widetilde{pk}_{d-1}) \\
pk_1 =& (X_1, Z_{1, 1}, \ldots, Z_{1, d-1}) := (\widetilde{pk}_d, \ldots, \widetilde{pk}_{2d-1}) \\
\vdots
\end{align*} obtaining $S := \left\{pk_i\right\}_{i=0}^{\left\lfloor \frac{q}{d}\right\rfloor}$.

\item $\texttt{M}$ picks two random tapes $\textbf{h}, \textbf{h}^\prime$ to simulate oracle query responses for $\mathcal{F}^{\texttt{B}}$.

\item $\texttt{M}$ executes $\mathcal{F}^{\texttt{B}}$ in a black box, using $S$ as input. Upon receiving a corruption query from $\mathcal{F}^{\texttt{B}}$ on some $pk_i$, $\texttt{M}$ makes a $\texttt{CO}$ query on $X_i$ and each $Z_{j,i}$, passing $sk_i$ back to $\mathcal{F}^{\texttt{B}}$. Each corruption query made by $\mathcal{F}^{\texttt{B}}$ consists of $d$ corruption queries made to $\texttt{CO}$ by $\texttt{M}$.

\item If $\mathcal{F}^{\texttt{B}}$ fails, or if $\mathcal{F}^{\texttt{B}}$ succeeds with all zero coefficients $\mu_X$ and $\mu_j$, then $\texttt{M}$ samples a random $w \in \mathbb{F}$, samples a random subset of challenge keys $\left\{pk^*_j\right\}_j \subseteq S$, samples random coefficients $\left\{h_j\right\}_j$, outputs $w, \left\{pk^*_j\right\}_j, \left\{h_j\right\}_j$, and terminates.

\item Otherwise, $\texttt{M}$ obtains two signature triples with the same message and ring, $(m, Q, \sigma), (m, Q, \sigma^\prime)$ at at least one non-zero aggregation coefficient. $\texttt{M}$ computes the challenge discrete logarithm $w = (c_\ell^\prime - c_\ell)^{-1}(s_\ell - s_\ell^\prime)$. $\texttt{M}$ outputs $w, \left\{\mu_X, \left\{\mu_j\right\}_j\right\}$, and $\left\{X_\ell, \left\{Z_{\ell, j}\right\}_j\right\}$.
\end{enumerate}

Denote with $t_1$ the time it takes for $\mathcal{M}$ to inspect the transcript, perform field operations, and process corruption queries for $\mathcal{F}^{\texttt{B}}$.  Then the algorithm $\texttt{M}$ runs in time at most $2(t+t_0) + t_1$.

To complete the proof, consider the overall success probability and timing of $\texttt{M}$. Since $\texttt{A}$ is a $(t, \epsilon, q)$-solver of the unforgeability game and these are successful signatures, there must be at least one query made to $\texttt{SO}$ corresponding to an uncorrupted challenge key linking to these signatures. In particular, $w \cdot G = W_\ell = \mu_X X_\ell + \sum_j \mu_j Z_{\ell,j}$ for some $(X_\ell, \left\{Z_{\ell, j}\right\}_j) \in Q$. The algorithm $\texttt{M}$ succeeds at the discrete logarithms of linear combinations game whenever $\mathcal{F}^{\texttt{B}}$ succeeds at forking $\texttt{B}$ and at least one coefficient $\mu_X$ and $\mu_j$ is non-zero; we denote the probability of obtaining any zero coefficients as $\mu$. We note that $\mu$ is negligible under the random oracle model. Thus, $\texttt{M}$ runs in time at most $2(t+t_0) + t_1$, has success probability exceeding $\epsilon\left(\frac{\epsilon}{q} - \frac{1}{2^\eta}\right) - \mu$.
\end{proof}

The proof of Theorem \ref{thm:nonsl} demonstrates that the validity of a triple implies that the aggregated private key $w$ is the discrete logarithm of the aggregated linking tag $\mathfrak{W}$ with respect to $H_\ell$ and is also the discrete logarithm of the aggregated key $W_\ell$ with respect to $G$. In this way, the linking tag of a valid signature must be the linking tag corresponding to at least one ring member, except possibly with negligible probability.

\begin{theorem}[No Alien Linking Tags]\label{cor:no-aliens}
If there exists a PPT algorithm $\texttt{A}$  that produces a valid signature triple $(m, Q, \sigma)$ with the scheme in Definition \ref{def:clsag}, then there exists a ring member in $Q$ whose aggregated key $W_\ell$ has the same discrete logarithm $w$ with respect to $G$ as $\mathfrak{W}$ has with respect to $H_\ell$, and this $w$ is known to $\texttt{A}$ (except possibly with negligible probability).
\end{theorem}

\begin{theorem}\label{thm:linkabilty}
The scheme in Definition \ref{def:clsag} is linkable under Definition \ref{def:acst-link-adv} and Definition \ref{def:pig-link}.
\end{theorem}

\begin{proof}
We show that valid, non-oracle signature triples from the scheme in Definition \ref{def:clsag} satisfying the corrupted key conditions in the game of Definition \ref{def:acst-link-adv} always link. Hence, any algorithm fails at that game except with negligible probability.

Assume that $\texttt{A}$,  while playing the game of ACST linkability from Definition \ref{def:acst-link-adv}, produces a pair of valid, non-oracle signature triples $(m, Q, \sigma)$, $(m^*, Q^*, \sigma^*)$ such that at most one key in $Q \cup Q^*$ is corrupted or outside of $S$. This algorithm can be forked and rewound as above to compute the aggregated private key used in computing each signature, say $w, w^*$. At most one key in $Q \cup Q^*$ is corrupted or outside of $S$. Since $\texttt{A}$ has knowledge of $w$, then $w$ is corrupted or outside of $S$, and likewise $w^*$ is corrupted or outside of $S$. Since at most one key in $Q \cup Q^*$ can be corrupted or outside of $S$, we conclude $w = w^*$.

Since key aggregation is collision resistant and $wG$ is the aggregated public key for some public key $(X_\ell, \left\{Z_{\ell, j}\right\}_j) \in Q \cap Q^*$, $w$ must be aggregated from a private key $(x_\ell, \left\{z_{\ell, j}\right\}_j)$ via the collision-resistant aggregation function. In both the case of single-key-oriented linkability and full-key-oriented linkability, the linkability tags are therefore exactly equal. Hence, with probability $1$, the pair of triples $(m, Q, \sigma)$, $(m^*, Q^*, \sigma^*)$ are linked, and $\texttt{A}$ fails at ACST linkability except with negligible probability.

Similarly, an algorithm that outputs $q+1$ unlinked signatures can be rewound to compute $2(q+1)$ signatures from which $q+1$ aggregated keys can be computed. Moreover, if these signatures are unlinked, then the $q+1$ aggregated keys are distinct, violating $q$-pigeonhole linkability.
\end{proof}

\begin{theorem}
The scheme in Definition \ref{def:clsag} is linkably anonymous.
\end{theorem}

\begin{proof}
We assume $\texttt{A}$ is a $(t, \epsilon, q)$-solver of linkable anonymity that has access to the random oracles $\mathcal{H}^p$, $\mathcal{H}^s$ and a signing oracle $\texttt{SO}$. We construct an algorithm $\texttt{B}$ has $\mathcal{H}^p$ oracle access, executes $\texttt{A}$ as a black box, simulates $\mathcal{H}^s$ queries made by $\texttt{A}$ with coin flips, simulates $\texttt{SO}$ queries made by $\texttt{A}$ via usual back-patching, and plays the random oracle decisional Diffie-Hellman game of Definition \ref{def:rom-ddh}. The algorithm $\texttt{B}$ works formally as follows.

\begin{enumerate}[(1)]
\item $\texttt{B}$ takes as input $S^{(b)} = \left\{(\widetilde{pk}_i, \widetilde{\mathfrak{T}}_i^{(b)})\right\}_{i=0}^{q-1}$.

\item $\texttt{B}$ partitions the challenge keys into lists of $d$ keys
\begin{align*}
pk_0 =&  (X_0, Z_{0, 1}, \ldots, Z_{0, d-1}) := (\widetilde{pk}_0, \ldots, \widetilde{pk}_{d-1}) \\
pk_1 =& (X_1, Z_{1, 1}, \ldots, Z_{1, d-1}) := (\widetilde{pk}_d, \ldots, \widetilde{pk}_{2d-1}) \\
\vdots
\end{align*} obtaining $S := \left\{pk_i\right\}_{i=0}^{\left\lfloor \frac{q}{d}\right\rfloor}$.

\item $\texttt{B}$ sends $S$ to $\texttt{A}$, who outputs a piar of indices $i_0, i_1$.

\item $\texttt{B}$ grants $\texttt{SO}$ access to $\texttt{A}$, simulating oracle queries for non-challenge keys via back-patching and responding with honestly generated signatures for challenge keys.

\item $\texttt{A}$ outputs a bit $b^\prime$; $\texttt{B}$ outputs the same $b^\prime$.
\end{enumerate}

Note that if $\texttt{A}$ succeeds with a non-negligible advantage $\left|\epsilon - \frac{1}{2}\right|$, then $\texttt{B}$ succeeds with the same advantage. Moreover, $\texttt{B}$ takes only some additional time to process keys and simulate $\texttt{SO}$ queries, both of which we assume are dominated by the time it takes $\texttt{A}$ to succeed.
\end{proof}


\section{Efficiency}\label{sec:efficiency}
Consider the space and time efficiency of Definition \ref{def:clsag}. We disregard any additional information typically broadcast alongside the signature, such as representations of the ring members.

A $d$-CLSAG signature with a ring size of $n$ contains $n+1$ field elements and $d$ group elements; signature size is $k_s(n+1) + k_p d$ where $k_s$ describes the size of field elements and $k_p$ describes the size of group elements.

To examine the verification time complexity, let $t_s$ and $t_p$ be the time complexity of evaluating the hash-to-scalar functions $\mathcal{H}^s$ and of evaluating the hash-to-point function $\mathcal{H}^p$, respectively. Let $t^{(i)}$ be the time complexity to evaluate a linear combination of $i$ terms; using specialized algorithms for multiscalar multiplication \cite{straus1964addition,pippenger1980evaluation}, such a linear combination can be evaluated much more quickly than a simple term-by-term computation. We note that it is also possible to cache multiples of group elements that are reused within verification for faster linear combination evaluation, but we do not differentiate this here. Using these, the time complexity of $d$-CLSAG verification is $(n+d)t_s + nt_p + 2nt^{(d+1)}$.

To compare to the efficiency of an MLSAG implementation from \cite{noether2016ring}, observe that $2$-CLSAG has equivalent functionality to an MLSAG signature (which is a $2$-LRS). An MLSAG signature used in this way produces $2n+1$ field elements and $1$ group element.

We produced a test implementation in C++ and tested signing and verification for MLSAG and $2$-CLSAG on a 2.1 GHz Opteron processor. Table \ref{table:timing} shows the results for different ring sizes. In particular, we note that for smaller anonymity sizes, $2$-CLSAG is uniformly faster than MLSAG. However, at very large ring sizes, MLSAG is faster due to additional computations involved in computing aggregation coefficients and key prefixing. Despite this eventual inefficiency, we note that the linear space requirements generally preclude the use of very large ring sizes in practice, making $2$-CLSAG an efficient improvement over MLSAG in both space and time.

\begin{table}[htp]
\begin{center}
\begin{tabular}{r|ll|ll}
& \multicolumn{2}{c|}{Verify} & \multicolumn{2}{c}{Sign} \\
\hline
Anonymity set & MLSAG & CLSAG & MLSAG & CLSAG \\
\hline
2 & 2.4 & 2.0 & 2.3 & 2.7 \\
4 & 4.7 & 4.0 & 4.6 & 4.6 \\
8 & 9.5 & 7.8 & 9.4 & 8.5 \\
16 & 18.9 & 15.9 & 18.9 & 16.5 \\
32 & 37.8 & 32.3 & 37.8 & 33.0 \\
64 & 75.4 & 67.5 & 75.9 & 68.3 \\
128 & 150 & 147 & 151 & 148 \\
256 & 301 & 344 & 303 & 346
\end{tabular}
\end{center}
\caption{Signing and verification times (ms) for MLSAG and $2$-CLSAG}
\label{table:timing}
\end{table}

\bibliographystyle{splncs04}
\bibliography{bibliography}

\end{document}