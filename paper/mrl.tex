\documentclass{mrl}

\usepackage{enumerate}
\usepackage[utf8]{inputenc}

\theoremstyle{plain}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}{Lemma}[section]
\theoremstyle{definition}
\newtheorem{remark}{Remark}[section]
\newtheorem{example}{Example}[section]
\newtheorem{defn}{Definition}[section]
\newtheorem{assu}{Assumption}[section]

\title{Compact linkable ring signatures and applications}
\authors{Brandon Goodell\footnote{\texttt{surae.noether@protonmail.com}} and Sarang Noether\footnote{\texttt{sarang.noether@protonmail.com}} and \texttt{RandomRun}}
\affiliations{Monero Research Lab}
\date{\today}
\type{RESEARCH BULLETIN}
\ident{MRL-0011}

\begin{document}

\begin{abstract}
We describe an efficient linkable ring signature scheme, compact linkable spontaneous anonymous group (CLSAG) signatures, for use in confidential transactions. Compared to the existing signature scheme used in Monero, CLSAG signatures are both smaller and more efficient to generate and verify for ring sizes of interest. We generalize the construction and show how it can be used to produce signatures with coins of different type in the same transaction.
\end{abstract}


\section{Introduction}
Ring signatures are used in Monero to provide transaction signer ambiguity. Originally, a simple Schnorr-like linkable ring signature \cite{liu2004linkable} was used that included previous one-time output public keys as possible signers. Later, the addition of Pedersen commitments to hide amounts necessitated a generalization to the signature \cite{noether2016ring} in order to prove transaction balance without revealing the signer.

The current ring signature construction used in Monero, MLSAG signatures, scale linearly with the number of ring members included in the signature. In particular, they require the inclusion of two scalars per ring member.

We note that the MLSAG signature scheme, while general enough to permit linking across multiple sets of input keys, is in practice used as a hybrid approach to a linkable ring signature. Indeed, each signature input consists of two keys: the first is a standard one-time output public key, and the second is a key computed using the associated Pedersen commitments. Linkability is only used for the first key, to ensure that double-spending does not occur.

This construction is flexible. For example, the format can be used for usual ring confidential transactions or could be modified to describe \textit{colored ring confidential transactions} with multiple so-called coin colors, allowing users to transact with multiple assets simultaneously.


\subsection{Our contribution}

In this work, we introduce a $d$-dimensional linkable ring multisignature ($d$-LRMS) scheme suitable for use in a colored ring confidential transaction scheme with $d$ colors. Our scheme is \textit{compact} in the sense that signature size scales with the sum of ring size and the dimension $d$; that is, increasing $d$ yields the same additional number of signature elements, regardless of the ring size. We prove our scheme is unforgeable up to the hardness of the $k$-one-more discrete logarithm problem. 

We call our signature scheme $d$-dimensional compact linkable spontaneous anonymous group ($d$-CLSAG) signatures. We demonstrate how to use this scheme for ring confidential transactions in Monero by replacing multi-layered linkable spontaneous anonymous group (MLSAG) signatures with $d$-CLSAG signatures.  The resulting scheme is more efficient in both signature size and verification time than current Monero transaction structures, and can be seamlessly integrated into the Monero transaction protocol.


\section{Notation}

In this document, we denote algorithms with typefont majuscule English letters like $\texttt{A}$, $\texttt{B}$, or $\texttt{O}$, or typefont names like $\texttt{Setup}$, $\texttt{KeyGen}$, and so on.  

Group parameters are denoted as a tuple $(p, \mathbb{G}, d, G)$ where $\mathbb{G}$ is an elliptic curve group with prime order $p$, $d$ is a dimension, and $G$ is a generator of $\mathbb{G}$. We denote integers, bits, indices, and scalars in $\mathbb{Z}/p\mathbb{Z}$ with minuscule English letters $x, y, z, b, c, i, j, k$, etc.\ and we denote group elements with majuscule English letters, $G, X, W$, and so on. We use miniscule Greek letters like $\sigma$ to describe signatures and majuscule calligraphic Latin letters like $\mathfrak{T}$ when describing linkability tags.

We denote column vectors in boldface, e.g.\ $(x_1, \ldots, x_d)^\top = \textbf{x}$, and matrices in underlined boldface, e.g.\ $((x_{1,1}, x_{1,2}, \ldots, x_{1,n}), \ldots, (x_{d,1}, \ldots, x_{d,n})) = (\textbf{x}_1, \textbf{x}_2, \ldots, \textbf{x}_n) = \underline{\textbf{x}}$ is a $d\times n$ matrix. We denote the Hadamard product of two vectors with $\circ$, so for any $\textbf{x} = (x_1, x_2, \ldots, x_d) = (x_i)_{i=1}^{d}$, and for any $\textbf{y} = (y_i)_{i=1}^{d}$, we denote the sequence $(x_i \cdot y_i)_{i=1}^{d}$ with $\textbf{x} \circ \textbf{y}$. We denote bitwise concatenation with the symbol $\mid \mid$.

We distinguish oracles with calligraphic font, e.g.\ $\mathcal{CO}$ denotes a corruption oracle, $\mathcal{SO}$ denotes a signing oracle. If the codomain of a random oracle is the field of scalars $\mathbb{Z}/p\mathbb{Z}$, we denote this $\mathcal{H}^s$ (hash-to-scalar). If the codomain is $\mathbb{G}$, we denote this $\mathcal{H}^p$ (hash-to-point).


\section{Linkable ring multisignatures}

In this section, we recall linkable ring signature (LRS) schemes, we modify the definition to account for $d$-dimensional keys for linkable ring multisignature (LRMS) schemes, and we provide two examples. We emphasize that our description does not present multisignatures as computed between mutually untrusted parties. We use the term to mean a $d$-of-$d$ threshold multisignature with all keys controlled by the same signer; in particular, we have none of the communication steps necessary for computing a multisignature.


\subsection{LRS and LRMS schemes}

\begin{defn}[LRS]\label{def:lrs}
A \textit{linkable ring signature scheme} is a tuple $(\texttt{Setup}, \texttt{KeyGen}, \texttt{Sign}, \texttt{Verify}, \texttt{Link})$ satisfying the following. 
\begin{itemize}
\item $\texttt{Setup}(1^\lambda) \to \textit{par}$. $\texttt{Setup}$ takes as input a security parameter $1^\lambda$, produces some public parameters $\textit{par}$. 

\item $\texttt{KeyGen}(1^\lambda, \textit{par}) \to (sk, pk)$. $\texttt{KeyGen}$ takes as input a security parameter $1^\lambda$ and public parameters $\textit{par}$. $\texttt{KeyGen}$ produces as output a private-public keypair $(sk, pk)$. 

\item $\texttt{Sign}\left(1^\lambda, \textit{par}, (m, \textbf{pk}, sk)\right) \to \left\{\bot_{\texttt{Sign}}, (\sigma, \mathfrak{T})\right\}$. $\texttt{Sign}$ takes as input a security parameter $1^\lambda$, public parameters $\textit{par}$, an arbitrary message $m \in \left\{0,1\right\}^*$, an ad hoc \textit{ring} of public keys $\textbf{pk} = \left\{pk_1, \ldots, pk_n\right\}$, and a secret key $sk$. $\texttt{Sign}$ produces as output either a distinguished failure symbol $\textit{out} = \bot_{\texttt{Sign}}$ or a signature-tag pair $\textit{out} = (\sigma, \mathfrak{T})$.

\item $\texttt{Verify}\left(1^\lambda, \textit{par}, (m, \textbf{pk}, (\sigma, \mathfrak{T}))\right) \to \left\{0,1\right\}$. $\texttt{Verify}$ takes as input a security parameter $1^\lambda$, public parameters $\textit{par}$, a message $m$, a ring of public keys $\textbf{pk}$, and a signature-tag pair $(\sigma, \mathfrak{T})$. $\texttt{Verify}$ produces as output a bit $b \in \left\{0,1\right\}$.

\item $\texttt{Link}\left(1^\lambda, \textit{par}, (\sigma, \mathfrak{T}), (\sigma^\prime, \mathfrak{T}^\prime)\right)$. $\texttt{Link}$ takes as input a security parameter $1^\lambda$, public parameters $\textit{par}$, and a pair of signature-tag pairs $(\sigma, \mathfrak{T}), (\sigma^\prime, \mathfrak{T}^\prime)$. $\texttt{Link}$ produces as output a bit $b \in \left\{0,1\right\}$. 
\end{itemize}
\end{defn}

We extend this to a scheme with $d$-dimensional keys. 

\begin{defn}[$d$-LRMS]
A \textit{$d$-dimensional linkable ring multisignature scheme} is a tuple of algorithms $(\texttt{Setup}, \texttt{KeyGen}, \texttt{Sign}, \texttt{Verify}, \texttt{Link})$ satisfying the following. 
\begin{itemize}
\item $\texttt{Setup}(1^\lambda) \to \textit{par}$. $\texttt{Setup}$ works as described in \ref{def:lrs}. 

\item $\texttt{KeyGen}(1^\lambda, \textit{par}) \to (\textbf{sk}, \textbf{pk})$. $\texttt{KeyGen}$ takes as input a security parameter $1^\lambda$ and public parameters $\textit{par}$. $\texttt{KeyGen}$ produces as output a private-public keypair $(\textbf{sk}, \textbf{pk})$ where each key is a $d$-dimensional vector. We refer to the first coordinate of each of these keys as the \textit{linking key} and the $d-1$ remaining coordinates (if there are any) are the \textit{auxiliary keys}.

\item $\texttt{Sign}\left(1^\lambda, \textit{par}, (m, \underline{\textbf{pk}}, \textbf{sk})\right) \to \left\{\bot_{\texttt{Sign}}, (\sigma, \mathfrak{T})\right\}$. $\texttt{Sign}$ takes as input a security parameter $1^\lambda$, public parameters $\textit{par}$, a message $m$, a vector of public keys $\underline{\textbf{pk}} = \left\{\textbf{pk}_1, \ldots, \textbf{pk}_n\right\}$ where each $\textbf{pk}_i$ is a $d$-dimensional public key, and a $d$-dimensional secret key $\textbf{sk}$. $\texttt{Sign}$ produces as output either a distinguished failure symbol $\bot_{\texttt{Sign}}$ or a signature-tag pair $(\sigma, \mathfrak{T})$. 

\item $\texttt{Verify}\left(1^\lambda, \textit{par}, (m, \underline{\textbf{pk}}, (\sigma, \mathfrak{T}))\right) \rightarrow \left\{0,1\right\}$. $\texttt{Verify}$ takes as input a security parameter $1^\lambda$, public parameters $\textit{par}$, a message $m$, a matrix of public keys $\underline{\textbf{pk}}$, and a signature-tag pair $(\sigma, \mathfrak{T})$. $\texttt{Verify}$ produces as output a bit $b \in \left\{0,1\right\}$. 

\item  $\texttt{Link}\left(1^\lambda, \textit{par}, (\sigma, \mathfrak{T}), (\sigma^\prime, \mathfrak{T}^\prime)\right)$. $\texttt{Link}$ works as described in \ref{def:lrs}.
\end{itemize}
\end{defn}

We refer to the linkability tag as the \textit{key image} for consistency with terminology in Monero. We also use the following terminology if the scheme satisfies the respective properties.
\begin{description}
\item[Correctly verified:] For any message $m$, $d$-dimensional secret key $\textbf{sk}$ with corresponding public key $\textbf{pk}$, and appropriately-sized matrix $\underline{\textbf{pk}} = \left\{\textbf{pk}_1, \ldots, \textbf{pk}_n\right\}$, if there exists an index $1 \leq \ell \leq n$ such that $\textbf{pk} = \textbf{pk}_\ell$, then $\texttt{Verify}(\texttt{Sign}(m, \underline{\textbf{pk}}, \textbf{sk})) = 1$.

\item[Correctly linkable:] For any messages $m$, $m^\prime$, any $d$-dimensional secret keys  $\textbf{sk}$ and $\textbf{sk}^\prime$ with equal linking keys (that is, with $\textbf{sk}_0 = \textbf{sk}^\prime_0$) and with corresponding public keys $\textbf{pk}$ and $\textbf{pk}^\prime$ respectively, any appropriately-sized pair of matrices $\underline{\textbf{pk}}$ and $\underline{\textbf{pk}}^\prime$, if $(\sigma, \mathfrak{T}) \leftarrow \texttt{Sign}(m, \underline{\textbf{pk}}, \textbf{sk})$ and $(\sigma^\prime, \mathfrak{T}^\prime) \leftarrow \texttt{Sign}(m^\prime, \underline{\textbf{pk}}^\prime, \textbf{sk}^\prime)$ such that $\underline{\textbf{pk}}_\ell = \textbf{pk}$ and $\underline{\textbf{pk}}_{\ell^\prime} = \textbf{pk}^\prime$, then
$\texttt{Link}((\sigma, \mathfrak{T}), (\sigma^\prime, \mathfrak{T}^\prime))=1$.
\end{description}

Note that linkability is only considered with respect to a single component of a matrix entry. When applied to Monero, this is important since only one such entry corresponds to an output public key for double-spend detection purposes.

%In the sequel, we omit $1^\lambda$ and $\textit{par}$ from the input of algorithms for clarity unless there is risk of confusion.


\subsection{Examples}

\begin{example}\label{ex:lsag}
The LSAG signature scheme from \cite{liu2004linkable} is a $1$-LRMS. In this example, $\texttt{Setup}$ always deterministically sets $d:=1$ (so we only use the linking key and there are no auxiliary keys). $\texttt{Setup}$ selects some $G \in \mathbb{G}$ to be a group generator for the group parameters $(p, \mathbb{G}, 1, G)$, two cryptographic hash functions $\mathcal{H}^s:\left\{0,1\right\}^* \to \mathbb{Z}/p\mathbb{Z}$ and $\mathcal{H}^p:\left\{0,1\right\}^* \to \mathbb{G}$. $\texttt{Setup}$ outputs $\textit{par} = (p, \mathbb{G}, 1, G, \mathcal{H}^s, \mathcal{H}^p)$.

$\texttt{KeyGen}$ produces as output a private key $x \in \mathbb{Z}/p\mathbb{Z}$ and a public key $X = xG$. $\texttt{Sign}$ takes as input a private key $y \in \mathbb{Z}/p\mathbb{Z}$, a message $m$, and a ring $\textbf{X} = \left\{X_1, \ldots, X_n\right\}$, and produces as output either a distinguished failure symbol $\bot_{\texttt{Sign}}$ or a signature-tag pair $(\sigma, \mathfrak{T})$.  

The signature scheme originally described in \cite{liu2004linkable} signs a message $m$ with a ring of keys $\textbf{X} = \left\{X_1, \ldots, X_n\right\}$ and a secret key $x$ corresponding to some $X_\ell$, using the linkability tag (key image) $\mathfrak{T} := x \mathcal{H}^p(\textbf{X})$. Unfortunately, this key image is unsuitable for use in Monero, as changing ring members will change the key image. This would allow the same key to be used twice in two different ring signatures. For use in Monero, we modify this key image to be independent of the non-signing ring members, $\mathfrak{T} := x \mathcal{H}^p(X_\ell)$. This allows these key images to be used for double-spend protection.

An LSAG signature on a message $m$ with ring $\textbf{X}$ using these key images is computed in the following way. First, the signer samples $\alpha, s_{\ell+1}, s_{\ell+2}, \ldots, s_{\ell-1} \in \mathbb{Z}/p\mathbb{Z}$ at random. Next, the signer computes basepoints $H_i = \mathcal{H}^p(X_i)$. Next, the signer computes $c_{\ell+1}  = \mathcal{H}^s(\textbf{X} \mid \mid m \mid \mid \alpha G \mid \mid \alpha H_\ell)$ and the signer computes each $c_{i+1} = \mathcal{H}^s(\textbf{X} \mid \mid m \mid \mid s_i G + c_i X_i \mid \mid s_i H_i + c_i \mathfrak{T})$ for $i = \ell+1, \ldots, \ell-1$, naturally identifying index $1$ with index $n+1$. The signer finishes by computing $s_\ell = \alpha - c_\ell x_\ell$ and publishing the signature-tag pair $(\sigma, \mathfrak{T})$ where $\sigma = (c_1, s_1, \ldots, s_n)$.

A purported LSAG signature-tag pair on a message $m$ with ring $\textbf{X}$ is verified in the following way. The verifier sets $c_1^\prime = c_1$ and computes $c_{i+1}^\prime = \mathcal{H}^s(\textbf{X} \mid \mid m \mid \mid s_i G + c_i^\prime X_i \mid \mid s_i H_i + c_i^\prime \mathfrak{T})$ for $i=1, 2, \ldots, n$. The verifier outputs $1$ when $c_{n+1}^\prime = c_1$ and $0$ otherwise. Note that all verifiers must list the keys in $\textbf{X}$ in an agreed-upon order for the above verification to work; either they should agree upon lexicographic or some other ordering.  LSAG signature-tag pairs are linked merely by comparing key images: two valid signatures with the same key image were signed with the same secret key (and, in the case of Monero, would signal an attempt to double-spend funds).
\end{example}

\begin{remark}
The key image modification in Example \ref{ex:lsag} is due to the basepoint of the key image $\mathfrak{T}$. As noted in \cite{liu2004linkable}, easy variations on key image formats are available. How or whether the security properties of LSAG signatures are retained in practical use given more flexible key image formats, while interesting, is beyond the scope of this work.
\end{remark}

\begin{example}\label{ex:mlsag}
The MLSAG signature scheme from \cite{noether2016ring} is a $2$-LRMS. In this example, $\texttt{Setup}$ always deterministically sets $d := 2$. Public keys are taken to be pairs of group elements $(X, Z) \in \mathbb{G}^2$. $\texttt{Sign}$ takes as input a private key vector $(x,z)$, a message $m$, and a matrix of public keys $\underline{\textbf{pk}} = \left\{\textbf{pk}_1, \ldots, \textbf{pk}_n\right\}$ where each $\textbf{pk}_i = (X_i, Z_i)$, each $X_i$ is the public key of a one-time transaction output, and each $Z_i$ is computed using combinations of Pedersen commitments that depend on the particular transaction type in use. %The commitments that form $Z_i$ can be adversarially selected and are not used in linking, and the secret key for $X_i$ can only be computed by the recipient except with negligible probability. 

A signature-tag pair $(\sigma, \mathfrak{T})$ is computed in the following way. Two rows of random signature data are sampled, say  $\alpha, \alpha^\prime, s_{\ell + 1}, s^\prime_{\ell + 1}, s_{\ell + 2}, s^\prime_{\ell + 2}, \ldots, s_{\ell -1}, s^\prime_{\ell - 1}$  and the basepoints $H_i = \mathcal{H}^p(X_i)$ are computed from the signing keys $X_i$ of each ring member $(X_i, Z_i)$. The key image $\mathfrak{T} = x_\ell H_\ell$ is computed. The following  challenges are computed
\begin{align*}
c_{\ell + 1} =& \mathcal{H}^s(\textbf{X} \mid \mid m \mid \mid \alpha G \mid \mid \alpha H_\ell \mid \mid \alpha^\prime G^\prime) \\
c_{i+1} =& \mathcal{H}^s(\textbf{X} \mid \mid m \mid \mid s_i G + c_i X_i \mid \mid s_i H_i + c_i \mathfrak{T} \mid \mid s_i^\prime G^\prime + c_i Z_i). \end{align*}The values $s_\ell = \alpha - c_\ell x_\ell$ and $s_\ell^\prime = \alpha^\prime - c_\ell z_\ell$ are computed. The signature is set $\sigma := (c_1, s_1, s_1^\prime, \ldots, s_n, s_n^\prime)$ and the signature-tag pair is published $(\sigma, \mathfrak{T})$. Verification proceeds as one would expect, succeeding if $c_{n+1}^\prime = c_1$ after the verifier computes each $H_i$ and each challenge
\begin{align*}
c_{2}^\prime =&  \mathcal{H}^s(\textbf{X} \mid \mid m \mid \mid s_1 G + c_1 X_1 \mid \mid s_1 H_1 + c_1 \mathfrak{T} \mid \mid s_1^\prime G^\prime + c_1 Z_1) \\
c_{i+1}^\prime =&  \mathcal{H}^s\left(\textbf{X} \mid \mid m \mid \mid s_i G + c_i^\prime X_i \mid \mid s_i H_i + c_i^\prime \mathfrak{T} \mid \mid s_i^\prime G^\prime + c_i^\prime Z_i \right).
\end{align*} 
Note this scheme is not compact in the sense that doubling key dimension going from $d=2$ in Example \ref{ex:lsag} to $d=2$ results in an asymptotic doubling of signature size. 
\end{example}


\section{A compact d-LRMS scheme}

We present a multisignature variant of LSAG signatures that is more compact than the previous examples. We loosely say that a $d$-LRMS scheme is compact if its signature sizes are not proportional to $d$. We call this scheme $d$-CLSAG to be concise. We show how to apply a $2$-CLSAG for use in ring confidential transactions, and how to apply $d$-CLSAG for colored ring confidential transactions. We make remarks on efficiency for both applications. In particular, we show that our $2$-CLSAG construction is more efficient in both space and verification time than the equivalent MLSAG construction.


\subsection{Implementation}\label{sec:implem}

\begin{defn}[$d$-CLSAG]\label{def:clsag}
The following tuple $(\texttt{Setup}, \texttt{KeyGen}, \texttt{Sign}, \texttt{Verify}, \texttt{Link})$ is a compact $d$-LRMS.

\begin{itemize}
\item $\texttt{Setup}(1^\lambda, d) \to \textit{par}$. $\texttt{Setup}$ takes as input a security parameter $1^\lambda$ and a public dimension $d$. $\texttt{Setup}$ selects a prime $p$, a group $\mathbb{G}$ with prime order $p$, selects a group generator $G \in \mathbb{G}$ uniformly at random, selects $d$ cryptographic hash functions $\mathcal{H}^s_0, \ldots, \mathcal{H}^s_{d-1}$ with codomain $\mathbb{Z}/p\mathbb{Z}$, selects a cryptographic hash function $\mathcal{H}^p$ with codomain $\mathbb{G}$. $\texttt{Setup}$ outputs $\textit{par} = \left( p,\mathbb{G}, d, G, \left\{\mathcal{H}^s_j\right\}_{j=0}^{d-1}, \mathcal{H}^p\right)$.\footnote{Note that domain separation can be used here to take one $\mathcal{H}^s$ and construct each $\mathcal{H}^s_j$ by defining $\mathcal{H}^s_j(x) := \mathcal{H}^s(j \mid\mid x)$.}

\item $\texttt{KeyGen}(1^\lambda, \textit{par}) \to (\textbf{sk}, \textbf{pk})$. $\texttt{KeyGen}$ takes as input the security parameter $1^\lambda$, public parameters $\textit{par}$. $\texttt{KeyGen}$ samples $\textbf{sk} \leftarrow (\mathbb{Z}/p\mathbb{Z})^d$, which we denote $\textbf{sk} = (x, z_1, \ldots, z_{d-1})$, and computes $\textbf{pk} := \textbf{sk} \circ \textbf{G}$ for $\textbf{G} = (G, G, \ldots, G) \in \mathbb{G}^d$. $\texttt{KeyGen}$ outputs $(\textbf{sk}, \textbf{pk})$. We say $x$ is the \textit{linking key} and the remaining keys $\left\{z_j\right\}$ are the \textit{auxiliary keys}.

\item $\texttt{Sign}\left(1^\lambda, \textit{par}, (m, \underline{\textbf{pk}}, \textbf{sk})\right) \to \left\{\bot_{\texttt{Sign}}, (\sigma, \mathfrak{T})\right\}$. $\texttt{Sign}$ takes as input the security parameter $1^\lambda$, public parameters $\textit{par}$, a message $m \in \left\{0,1\right\}^*$, a matrix of public keys $\underline{\textbf{pk}} = (\textbf{pk}_1, \ldots, \textbf{pk}_n)$ where each $\textbf{pk}_i = (X_i, Z_{i,1}, \ldots, Z_{i,d-1}) \in \mathbb{G}^d$, and a secret key vector $\textbf{sk} = (x,z_1, \ldots, z_{d-1}) \in (\mathbb{Z}/p\mathbb{Z})^d$. $\texttt{Sign}$ does the following.

\begin{enumerate}
\item $\texttt{Sign}$ looks for the signing index $\ell$ such that $(x, z_1, \ldots, z_{d-1}) \circ (G, G, \ldots, G) = \textbf{pk}_\ell$. If no such index exists, $\texttt{Sign}$ outputs $\bot_{\texttt{Sign}}$ and terminates.

\item Otherwise, $\texttt{Sign}$ samples $\alpha \in \mathbb{Z}/p\mathbb{Z}$ and $\left\{s_i\right\}_{i \neq \ell} \in (\mathbb{Z}/p\mathbb{Z})^{n-1}$.

\item $\texttt{Sign}$ computes the \textit{aggregation coefficients} $\mu_X$ and $\{\mu_j\}_{j=1}^{d-1}$, the \textit{linkability tag} or \textit{key image} $\mathfrak{T}$, and auxiliary key images $\{\mathfrak{D}_j\}_{j=1}^{d-1}$:
\begin{align*}
\mathfrak{T} \leftarrow& x \mathcal{H}^p(X_\ell) & \mu_X \leftarrow& \mathcal{H}^s_0(\underline{\textbf{pk}} \mid \mid \mathfrak{T} \mid \mid \{\mathfrak{D}_j\}_{j=1}^{d-1}) \\
\{\mathfrak{D}_j\} \leftarrow&  \{z_j \mathcal{H}^p(X_\ell)\} & \mu_j \leftarrow& \mathcal{H}^s_j(\underline{\textbf{pk}} \mid \mid \mathfrak{T} \mid \mid \{\mathfrak{D}_j\}_{j=1}^{d-1}).
\end{align*}

\item For $i = \ell, \ell+1, \ldots, \ell-1$, identifying index $n$ with index $1$ as usual, $\texttt{Sign}$ computes
\begin{align*}
L_\ell =& \alpha G & L_i =& s_i G + c_i \left(\mu_X X_i + \sum_{j=1}^{d-1} \mu_jZ_{i,j}\right)\\
R_\ell =& \alpha \mathcal{H}^p(X_\ell) & R_i =& s_i \mathcal{H}^p(X_i) + c_i \left(\mu_X \mathfrak{T} + \sum_{j=1}^{d-1} \mu_j \mathfrak{D}_j\right) \\
c_{\ell+1} =& \mathcal{H}^s_0(\underline{\textbf{pk}} \mid \mid m \mid \mid L_\ell \mid \mid R_\ell) & c_{i+1} =& \mathcal{H}^s_0(\underline{\textbf{pk}} \mid \mid m \mid \mid L_i \mid \mid R_i)
\end{align*} and lastly computes $s_\ell = \alpha - c_\ell (\mu_X x_\ell + \sum_{j=1}^{d-1} \mu_jz_{\ell,j})$.

\item $\texttt{Sign}$ sets the signature $\sigma = (c_1, s_1, \ldots, s_n, \{\mathfrak{D}_j\}_{j=1}^{d-1})$ and publishes the signature-tag pair $(\sigma, \mathfrak{T})$.
\end{enumerate}

\item $\texttt{Verify}\left(1^\lambda, \textit{par}, m, \underline{\textbf{pk}}, (\sigma, \mathfrak{T})\right) \to \left\{0,1\right\}$. $\texttt{Verify}$ takes as input the security parameter $1^\lambda$, public parameters $\textit{par}$, a message $m$, a matrix $\underline{\textbf{pk}} = ((X_i, Z_{i,1}, \ldots, Z_{i,d-1}))_{i=1}^{n}$, and a signature-tag pair $(\sigma, \mathfrak{T})$. $\texttt{Verify}$ does the follwoing.

\begin{enumerate}
\item If $n > N$, or any coordinate of any ring member is not in $\mathbb{G}$, or if $\sigma$ cannot be parsed as $(c_1, s_1, \ldots, s_n, \mathfrak{D}_1, \ldots, \mathfrak{D}_{d-1})$ for some $c_1 \in \mathbb{Z}/p\mathbb{Z}$, some $s_i \in \mathbb{Z}/p\mathbb{Z}$, and some $\mathfrak{D}_j \in \mathbb{G}$, or if $\mathfrak{T} \notin \mathbb{G}$, $\texttt{Verify}$ produces $0$ as output and terminates.

\item Otherwise, $\texttt{Verify}$ parses $(c_1, s_1, \ldots, s_n, \{\mathfrak{D}_j\}_{j=1}^{d-1}) \leftarrow \sigma$, computes each $\mathcal{H}^p(X_i)$, and compute the aggregation coefficients as above.

\item $\texttt{Verify}$ sets $c_1^\prime := c_1$ and, for $i=1, 2, \ldots, n-1$, computes the following.
\begin{align*}
L_i :=& s_i G + c_i^\prime \left(\mu_X X_i + \sum_{j=1}^{d-1} \mu_jZ_{i,j}\right) \\ 
R_i :=& s_i \mathcal{H}^p(X_i) + c_i^\prime\left(\mu_X \mathfrak{T} + \sum_{j=1}^{d-1} \mu_j \mathfrak{D}_j\right)\\
c_{i+1}^\prime :=& \mathcal{H}^s_0\left(\underline{\textbf{pk}} \mid \mid m \mid \mid L_i \mid \mid R_i\right)
\end{align*}
\item If $c_{n+1}^\prime = c_1$, $\texttt{Verify}$ produces $1$ as output. Otherwise, $\texttt{Verify}$ produces $0$ as output.
\end{enumerate}

\item $\texttt{Link}\left(1^\lambda, \textit{par}, (\sigma_1, \mathfrak{T}_1), (\sigma_2, \mathfrak{T}_2)\right) \to \left\{0,1\right\}$. $\texttt{Link}$ takes as input the security parameter $1^\lambda$, public parameters $\textit{par}$, and two signature-tag pairs $((\sigma_1, \mathfrak{T}_1), (\sigma_2, \mathfrak{T}_2))$. If $\mathfrak{T}_1 \in \mathbb{G}$ and $\mathfrak{T}_2 \in \mathbb{G}$ and $\mathfrak{T}_1 = \mathfrak{T}_2$, $\texttt{Link}$ produces $1$ as output. Otherwise, $\texttt{Link}$ produces $0$ as output.
\end{itemize}

\end{defn}

We use the usual definition of correct verification and correct linkability, both of which are straightforward to verify directly from the implementation. Later, we discuss the security of this implementation. 

\begin{remark}
It may be possible to compress signatures further by  computing the coefficients $\mu_j$ without the inputs $\mathfrak{D}_j$ and publishing $\sigma = (c_1, s_1, \ldots, s_n, \sum_j \mu_j \mathfrak{D}_j)$ only, reducing signature sizes for $d > 1$ further. 

The security of this variant is not proven here and is a good avenue for future work. The variant is not relevant for Monero, since $d=1$ for single-asset ring confidential transactions.
\end{remark}

\begin{remark}


Note that the signature is computed with the aggregated secret $w = \mu_X x_\ell + \sum_j \mu_j z_{\ell,j}$. This method of aggregating keys has two properties of importance.

First, under the random oracle model, the map defined by mapping $(x, z_1, \ldots, z_{d-1}) \mapsto w$ is collision resistant and anyone with knowledge of $(x_\ell, z_{\ell,1}, \ldots, z_{\ell,d-1})$ can compute the aggregated secret key $w$. More than one choice of $(x_\ell, z_{\ell,1}, \ldots, z_{\ell,d-1})$ could map to the same aggregated key, but collision resistance implies second pre-image resistance. Hence, given some $W = wG$ for an unknown aggregated secret key $w$ aggregated from some secret key $(x_\ell, z_{\ell,1}, \ldots, z_{\ell,d-1})$, an attacker has at most a negligible chance of finding a second secret key $(x_\ell^\prime, z_{\ell,1}^\prime, \ldots, z_{\ell,d-1}^\prime)$ that aggregates to the same secret $w$. This prevents the attacker from using an adversarially generated secret key that coincidentally aggregates to the same $w$ as some challenge key.


Second, under the random oracle model, the map is resistant to key cancellation. That is to say, an attacker has at most a negligible chance of selecting a secret key $(x_\ell, z_{\ell, 1}, \ldots, z_{\ell, d-1})$ with coordinates that cancel in the sum $w$; except with negligible probability, $w$ is dependent upon all bits of all coordinates of a secret key $(x, z_1, \ldots, z_{d-1})$. 

\end{remark}

\subsection{Efficiency}

Consider the space and time efficiency of Definition \ref{def:clsag}. A $d$-CLSAG signature with a ring size of $n$ contains $n+1$ scalars and $d$ group elements, so this scheme is compact. In practice, signatures are broadcast with additional information such as references to the ring members. However, this is outside the scope of our definitions.

To examine the verification time complexity, let $k_s$ and $k_p$ be the time complexity of evaluating the hash-to-scalar functions $\mathcal{H}^s$ and of evaluating the hash-to-point function $\mathcal{H}^p$, respectively. Let $k^{(i)}$ be the time complexity to evaluate a scalar-point linear combination of $i$ terms; using specialized algorithms like Straus or Pippenger multiexponentiation (or others, based on $i$), such a linear combination can be evaluated much more quickly than a simple term-by-term computation. We note that it is also possible to cache multiples of points that are reused within verification for faster linear combination evaluation, but we do not differentiate this here. Using these, the time complexity of $d$-CLSAG verification is $(n+d)k_s + nk_p + 2nk^{(d+1)}$.

To compare to the current MLSAG scheme in Monero, note that $2$-CLSAG has equivalent functionality. The current Monero implementation requires $2n+1$ scalars and $1$ group element. 

To determine the feasibility of implementation in Monero, we produced a test implementation using the Monero codebase and tested signing and verification for MLSAG and $2$-CLSAG on a 2.1 GHz Opteron processor. Table \ref{table:timing} shows the results for different ring sizes. In particular, we note that for ring sizes of interest to Monero (the current network-enforced size is $11$), CLSAG is uniformly faster than MLSAG. However, at very large ring sizes, MLSAG is faster due to additional computations involved in computing aggregation coefficients and key prefixing.

\begin{table}[htp]
\begin{center}
\begin{tabular}{r|ll|ll}
& \multicolumn{2}{c|}{Verify} & \multicolumn{2}{c}{Sign} \\
\hline
Ring size & MLSAG & CLSAG & MLSAG & CLSAG \\
\hline
2 & 2.4 & 2.0 & 2.3 & 2.7 \\
4 & 4.7 & 4.0 & 4.6 & 4.6 \\
8 & 9.5 & 7.8 & 9.4 & 8.5 \\
16 & 18.9 & 15.9 & 18.9 & 16.5 \\
32 & 37.8 & 32.3 & 37.8 & 33.0 \\
64 & 75.4 & 67.5 & 75.9 & 68.3 \\
128 & 150 & 147 & 151 & 148 \\
256 & 301 & 344 & 303 & 346
\end{tabular}
\end{center}
\caption{Signing and verification times (ms) for MLSAG and $2$-CLSAG}
\label{table:timing}
\end{table}


\section{Applications}

\subsection{Single-asset ring confidential transactions}\label{sec:ringct}

As mentioned above, it is possible to use $2$-CLSAG as a replacement for MLSAG signatures in Monero for equivalent functionality. Currently, Monero uses MLSAG signatures for two different transaction types: full and simple.

Full transactions are only used when spending a single input. They leverage the fact that in a balanced transaction, the difference between input and output commitments is a commitment to zero; the signer can therefore use such differences as the second component of key vectors in the signature and sign using the known secret key at the signing index.

Simple transactions are used when spending multiple inputs. Each spent input requires a separate signature, as a naive extension of full transactions presents an index linking issue. The signer first generates auxiliary commitments for each spent input using the same value but a different blinder. This means it is possible to use the difference between input and auxiliary commitments as a commitment to zero for the purpose of signing. By choosing all blinders at random except one, the signer can construct the auxiliary commitments such that the difference between auxiliary and output commitments is zero, proving balance.

Both transaction types can be used with $2$-CLSAG, since linkability is not considered for the second key component used in the transaction protocols.


\subsection{Multi-asset ring confidential transactions (MARCTs)}

It is possible to use a straightforward $d$-CLSAG construction to accommodate transactions spending $d-1$ \textit{types} or \textit{colors} of assets separately within the same transaction and signature. To do so, Monero outputs are extended to have a separate commitment to each asset type value. When spending an output, either a full or simple transaction (discussed above) is used; we simply copy the method used to compute commitment public keys in the signature to additional dimensions of the $d$-CLSAG signature, using only the commitments for a particular asset type in each. This separation ensures that the transaction balances in each asset type separately, while taking advantage of the scaling benefits of $d$-CLSAG compared to the equivalent MLSAG signature construction.


\subsubsection{Informal description of MARCT implementation}\label{ex:dualasset}

In this section, we leverage $\Pi_C^{(d)}$ for use in ring confidential transactions on $d-1$ different assets (or colors) with a pegged exchange rate between colors. We analyze the cost (in terms of weight and sync time) to the blockchain of our proposal compared to a similar proposal using $d$-MLSAG signatures. We present only the case $d=3$ in this section to represent two colors, leaving extensions for future work.

Consider the canonical example of colored currency with a fixed peg between two colors: dollars and pennies with a $100:1$ exchange rate between them. Define an exchange rate by determining some constants $\gamma_C, \gamma_D$ on $\left\{1, 2, \ldots, 2^{\xi - 1}\right\}$, (in this example, $\gamma_C = 1$ and $\gamma_D = 100$). Let $G, G^\prime$ be public group elements with unknown discrete logarithms with respect to each other where $G$ is the output from $\texttt{Setup}$ for a $d$-CLSAG.  Let $(\texttt{Prove}, \texttt{Ver})$ be a zero-knowledge sound range proving scheme, such as that described in \cite{bulletproofs}, and let $(\texttt{Com}, \texttt{Open})$ be a Pedersen commitment scheme such that $\texttt{Com}(r,v) = rG + v G^\prime$.

For the sake of this example, we define a public trading key to be a tuple $(X, C, D, P)$ where $X, C, D \in \mathbb{G}$, $C$ and $D$ are commitments and $P$ is a batched range proof from $\texttt{Prove}$ covering the values of both $C$ and $D$. We define a transaction key to be a tuple $(m, \textbf{Q}, \textbf{O}, (f_C, f_D), (\sigma, \mathfrak{T}), \textit{aux})$ where $\textbf{Q}$ is a ring of $n$ public trading keys  $\textbf{Q} = \left\{(X_i, C_i, D_i, P_i)\right\}_{i=1}^{n}$, $\textbf{O}$ is a set of $n^\prime$ output public trading keys $\textbf{O} = \left\{(X_i^\prime, C_i^\prime, D_i^\prime, P_i^\prime)\right\}_{i=1}^{n^\prime}$, $f_C$ is a plaintext list of fees to be paid from $C$, $f_D$ is a plaintext list of fees to be paid from $D$, $S=(\sigma, \mathfrak{T})$ is a CLSAG signature-tag pair.

We say a simple transaction key is valid if the following are satisfied:
\begin{itemize}
\item every input ring member $(X_i, C_i, D_i, P_i) \in \textbf{Q}$ has a valid range proof $P_i$ so $\texttt{Ver}(P_i) = 1$; and
\item every output range proof $P_k^\prime$ is valid so $\texttt{Ver}(P_k^\prime)=1$; and
\item the signature-tag pair $(\sigma, \mathfrak{T})$ passes $d$-CLSAG verification $\texttt{Verify}(m, \underline{\textbf{pk}}, (\sigma, \mathfrak{T})) = 1$ for the modified ring \[\textbf{pk} = \begin{pmatrix} X_1 & X_2 & \cdots & X_n \\ Z_1 & Z_2 & \cdots & Z_n\end{pmatrix}\] where each $Z_i = \gamma_C (C_i - f_C G^\prime - \sum_k C_k^\prime) + \gamma_D ( D_i - f_D G^\prime - \sum_k D_k^\prime)$.
\end{itemize}

As before, this CLSAG signature demonstrates knowledge of the discrete logarithm of some $x_\ell$, knowledge of the opening information for the input and output commitments, and that the opening information for the commitments balance with the fees $f_C$ and $f_D$.  After all, when the amounts in $C_\ell$ and $D_\ell$ balance with the fees $f_C$ and $f_D$ together with the sum of the amounts in each $C_k^\prime$ and $D_k^\prime$, and when the signer knows all the openers for all these commitments, the point $\gamma_C(C_\ell - f_C G^\prime - \sum_k C_k^\prime) + \gamma_D(D_\ell - f_D G^\prime - \sum_k D_k^\prime)$ will be a usual public key with basepoint $G$ whose secret key is known by the signer.


\subsubsection{Flexible pegs, coin spectra, privacy, and further extensions}

The validity of a MARCT without any exchange at all between assets is also possible, allowing for assets to be segregated. 

On the other hand, different exchange coefficients $\gamma_C$ and $\gamma_D$ are certainly possible.  Just so long as there is a way for validators to come to an agreement upon exchange rate coefficients, validators can also convince themselves that transactions accordingly balance. Extending the model of simple ring confidential transactions with two colors to more than two colors is a straightforward exercise.

Further extensions with more immediate value may be possible. One open question is how to modify the above scheme to mask exchange rates. Another open question involves formalizing flexible-peg models of full colored ring confidential transactions between many colors (a spectrum?). These extensions represent fundamental building blocks for a system of smart transactions that respect user privacy. 


\appendix


\section{Security: Unforgeability}

\subsection{Hardness}

Unforgeability comes from the $k$-OMDL hardness assumption. 

\begin{defn}[k-OMDL problem]
Let $k \in \mathbb{N}$. We say a PPT algorithm $\texttt{A}$ is a $(t, \epsilon)$-solver of the $k$-OMDL problem if, within time at most $t$ and with probability at least $\epsilon$, $\texttt{A}$ can succeed at the following.

\begin{enumerate}
\item The challenger uses group parameters $(p, \mathbb{G}, G)$ and picks $G_1, G_2, \ldots, G_{k}, G_{k+1} \in \mathbb{G}$ (the targets) uniformly at random from $\mathbb{G}$. The challenger sends the group parameters and $\left\{G_i\right\}$ to $\texttt{A}$.

\item $\texttt{A}$ is granted access to a corruption oracle $\mathcal{CO}$ that takes as input some $G_i$ sent to $\texttt{A}$ and produces as output the discrete logarithm of $G_i$ with respect to $G$, i.e.\ some $x_i \in \mathbb{Z}/p\mathbb{Z}$ such that $G_i = x_i G$.

\item $\texttt{A}$ produces as output a sequence of $k+1$ scalars $x_1, \ldots, x_{k+1} \in \mathbb{Z}/p\mathbb{Z}$, counting as a success if:
\begin{enumerate}[(i)]
\item for each $x_i$, there exists some index $1 \leq j(i) \leq k+1$ such that $G_{j(i)} = xG$ and
\item $\texttt{A}$ made no more than $k$ queries to $\mathcal{CO}$. 
\end{enumerate}
\end{enumerate}
\end{defn}

\subsection{Defining forgeries}
We use a modified version of the definition of existential forgery with insider corruption for a ring signature by Bender, Katz, and Morselli \cite{bender}. By using linkability tags, our definition is slightly stronger; we allow forgeries to count as successful either with partially-corrupted rings or with messages that the signing oracle has signed before, just so long as neither the signature nor the linkability tag from the forgery appear as output from any oracle query in any transcript. This prevents a malicious party with the ability to persuade users to sign maliciously selected messages with maliciously selected ring members from constructing ostensibly valid, previously-unseen signature-tag pairs.

We use the following in the next definition. Let $n(-)$ be a positive polynomial. Let $\mathcal{H}^s:\left\{0,1\right\}^* \to \mathbb{Z}/p\mathbb{Z}$ be modeled as a random oracle. Let $\mathcal{CO}$ be a corruption oracle that takes as input a public key $\textbf{pk}$ from the list of challenge keys and produces as output the corresponding secret key $\textbf{sk}$ and the linkability tag $\mathfrak{T}$. Let $C$ be the set of all keys in the transcript of queries made by $\texttt{A}$ to $\mathcal{CO}$. Let $T_C$ be the set of all linkability tags that appear as output from such a query. Let $\mathcal{SO}$ be a signing oracle that takes as input some $(m, \underline{\textbf{pk}}^\prime, \ell)$ such that $\underline{\textbf{pk}^\prime}$ is a matrix of challenge key vectors (i.e.\ each column is in $\textbf{pk}$) and produces as output a signature-tag pair $(\sigma, \mathfrak{T})$ such that $\texttt{Verify}(m, \underline{\textbf{pk}}^\prime, \sigma, \mathfrak{T}) = 1$ and $\mathfrak{T}$ is the linkability tag for the $\ell^{th}$ key in $\underline{\textbf{pk}}^\prime$.

\begin{defn}[Existential unforgeability of linkable ring signatures with respect to insider corruption]\label{def:unf}

We say a PPT algorithm $\texttt{A}$  is a $(t, \epsilon, q_h, q_c, q_s,  n(-))$-forger of a linkable ring signature scheme if, within time at most $t$ and with at most $q_h$ oracle queries to $\mathcal{H}^s$, at most $q_c$ oracle queries to $\mathcal{CO}$, and at most $q_s$ queries to $\mathcal{SO}$, $\texttt{A}$ can succeed at the following game with probability at least $\epsilon$.
\begin{enumerate}
\item The challenger selects $\left\{(\textbf{sk}_i, \textbf{pk}_i)\right\}_{i=1}^{n(\lambda)} \leftarrow \texttt{KeyGen}(1^\lambda)$ and sends $\underline{\textbf{pk}} = \left\{\textbf{pk}_i\right\}_{i=1}^{n(\lambda)}$ to $\texttt{A}$. 

\item $\texttt{A}$ is granted access to a corruption oracle $\mathcal{CO}$, random oracle $\mathcal{H}^s$, and the signing oracle $\mathcal{SO}$.

\item $\texttt{A}$ outputs a message $m$, a ring of at most $n$ public keys $\underline{\textbf{pk}}^\prime$, and a signature-tag pair $(\sigma, \mathfrak{T})$. This output is a success if $\underline{\textbf{pk}}^\prime \subseteq \underline{\textbf{pk}}$ and $\mathfrak{T} \notin T_C$ and $\sigma$ has not been output by $\mathcal{SO}$ and $\texttt{Verify}(m, \underline{\textbf{pk}}^\prime, \sigma, \mathfrak{T}) = 1$.

\end{enumerate}
\end{defn}

These success requirements ensure that (i) any ring member whose linkability tag is $\mathfrak{T}$ has not yet had its corresponding private key corrupted by $\mathcal{CO}$; and (ii) the signature itself has not been produced by the signing oracle. This allows the attacker to perhaps re-use a message $m$ and linkability tag $\mathfrak{T}$ from a previous oracle query. If the attacker can produce a new signature $\sigma^\prime$ on a message that has been signed before by the oracle then the new signature should still count as a forgery.


\begin{remark}
Note that if the corruption oracle merely acted by computing arbitrary discrete logarithms, then an adversary could do the following: take some target $\textbf{pk}$ from the challenge set, apply a permutation to the coordinates of $\textbf{pk}$, pass the permuted key through $\mathcal{CO}$, obtain the discrete logarithm of the first (signing) key of $\textbf{pk}$, compute the linkability tag for this signing key, and lastly produce a signature using $\texttt{Sign}$. 

Such a signature would pass validation and not be described as a forgery according to our definition. Our definition avoids this problem by requiring the corruption oracle only be queried with challenge keys. This way, a corruption oracle can be simulated for the black box execution of $\texttt{A}$.
\end{remark}

\subsection{The Forking Lemma} To prove that the existence of a forger implies that of a $k$-OMDL solver, we use the forking lemma. In the following, we presume the bit length $\eta$ is used to describe group elements in $\mathbb{G}$ and scalars in $\mathbb{Z}/p\mathbb{Z}$, i.e.\ $\eta = O(\left|p\right|)$.

\begin{lemma}[General Forking Lemma]\label{lem:fork}
Let $q, \eta \geq 1$. Let $\texttt{A}$ be any PPT algorithm which takes as input some $x_\texttt{A} = (x, \underline{h})$ where $\underline{h} = (h_1, \ldots, h_q)$ is a sequence of oracle query responses ($\eta$-bit strings) and returns as output $y_{\texttt{A}}$ either a distinguished failure symbol $\bot$ or a pair $(\textit{idx}, y)$ where $\text{idx} \in [q]^2$ and $y$ is some output. Let $\epsilon_{\texttt{A}}$ denote the probability that $\texttt{A}$ does not output $\bot_{\texttt{A}}$ (where this probability is taken over all random coins of $\texttt{A}$, the distribution of $x$, all choices $\underline{h}$). Let $\mathcal{F} = \mathcal{F}^{\texttt{A}}$ be the forking algorithm for $\texttt{A}$ described below. The accepting probability of $\mathcal{F}$ satisfies \[\epsilon_{\mathcal{F}} \geq \epsilon_{\texttt{A}} \left(\frac{\epsilon_{\texttt{A}}}{q} - \frac{1}{2^\eta}\right).\]
\end{lemma}

We refer the reader to \cite{bellare} for a proof of this lemma, which demonstrates that if executing some $\texttt{A}$ has non-negligible acceptance probability, then forking $\texttt{A}$ does as well. Since all queries before the $(j^*)^{th}$ query are identical in both transcripts, the input of the $(j^*)^{th}$ query is also identical. Since oracle queries $h_{j^*}^{\prime}, h_{j^*+1}^{\prime}, \ldots$ are newly sampled upon receiving the first output from $\texttt{A}$, the queries $h_{j^*} \neq h_{j^*}^\prime$ except with negligible probability. All subsequent computations in the signature that are common in both transcripts will have the same results only with negligible probability. 


\subsubsection{Using a forger in the Forking Lemma}

Note that a forger according to Definition \ref{def:unf} is not directly compatible with the forking lemma; the output is some $y = (m, \textbf{pk}, \sigma, \mathfrak{T})$ and no $\textit{idx}$ is included.  However, without loss of generality, we can execute $\texttt{A}$ in a black box that extracts from the transcript of $\texttt{A}$ some $\textit{idx} = (j^*, i^*)$ in the following way. 

For each query for any $c_{i+1}$ that appears in the successful forgery, there exists a corresponding index $j(i)$ that satisfies $c_{i+1} = h_{j(i)}$. The black box executing $\texttt{A}$ looks at the transcript and extracts the index pair $\textit{idx} = (i^*, j^*)$ that indicates where in the random oracle transcript we can find the very first oracle query made by $\texttt{A}$ to $\mathcal{H}^s$ for any challenge $c_{i^*+1}$ used in the successful forgery. If such a pair $(i^*, j^*)$ can be found, the algorithm wrapping $\texttt{A}$ can then output $(\textit{idx}, y)$ with only a negligible difference in advantage. 

Moreover, each $c_{i+1}$ used in the signature verification is computed by $\texttt{A}$ by querying $\mathcal{H}^s$  in the transcript of $\texttt{A}$ leading to a successful forgery. In particular, the challenge could not have been guessed without making the query (except with negligible success). Indeed, a probabilistic algorithm could flip coins to guess the hash output, but this is successful with negligible probability. Of course, although the index $i^*$ may not have been decided by $\texttt{A}$ when the query was made, but by the time the forgery is complete, the index $i^*$ has been assigned.

Hence, without loss of generality, we can assume that $\texttt{A}$ has been appropriately wrapped so is compatible with the forking lemma without impacting its advantage. One algorithm $\mathcal{F}^\texttt{A}$ that works in Lemma \ref{lem:fork} works in the following way.

\begin{enumerate}
\item $\mathcal{F}$ takes as input some $x$ and $\mathcal{F}$ selects the random tape for $\texttt{A}$.
\item $\mathcal{F}$ selects some $\underline{h} = (h_1, \ldots, h_q)$ at random by flipping coins, and $\mathcal{F}$ executes $y_\texttt{A} \leftarrow \texttt{A}(x,\underline{h})$.
\item If $y_{\texttt{A}} = \bot_{\texttt{A}}$, then $\mathcal{F}$ outputs $\bot_{\mathcal{F}}$ and terminates. Otherwise, $y_{\texttt{A}} = (\textit{idx}, y)$ for some $\textit{idx}=(i^*,j^*)$ and some output $y$ and $\mathcal{F}$ selects new oracle queries $h_{j^*}^\prime, h_{j^*+1}^\prime, \ldots, h_q^\prime$, and glues the hash challenges together $\underline{h}^\prime = (h_1, \ldots, h_{j^*-1}, h_{j^*}^\prime, h_{j^*+1}^\prime, \ldots, h_q^\prime)$. 
\item If $h_{j^*} = h_{j^{*}}^\prime$, then $\mathcal{F}$ outputs $\bot_{\mathcal{F}}$ and terminates. Otherwise, $h_{j^*} \neq h_{j^{*}}^\prime$ and $\mathcal{F}$ executes $y_\texttt{A}^\prime \leftarrow \texttt{A}(x,\underline{h}^\prime)$.
\item If $y_{\texttt{A}}^\prime = \bot_{\texttt{A}}$, then $\mathcal{F}$ outputs $\bot_{\mathcal{F}}$ and terminates. Otherwise, $y_{\texttt{A}}^\prime = (\textit{idx}^{\prime}, y^\prime)$. If $\textit{idx} \neq \textit{idx}^\prime$, $\mathcal{F}$ outputs $\bot_{\mathcal{F}}$ and terminates. Otherwise, $\mathcal{F}$ outputs $(\textit{idx}, y, \underline{h}, y^\prime, \underline{h}^\prime)$.
\end{enumerate}


We note that $\mathcal{F}^{\texttt{A}}$ executed in a black box can be fed the oracle queries $\underline{h}$ and $\underline{h}^\prime$ and so these can be assumed to be output as well without loss of generality or impacting acceptance probability.


Of course, if $\texttt{A}$ runs in time at most $t$, $\mathcal{F}^{\texttt{A}}$ runs in time at most $2t+s$ where $s$ denotes the (negligible) time it takes $\mathcal{F}^{\texttt{A}}$ to select the random tape for $\texttt{A}$, select the oracle query sequences $\underline{h}$ and $\underline{h}^\prime$, and output the results. 

\subsection{The Oracles}

Of course, any oracle queries made by $\texttt{A}$ must be handled by $\mathcal{F}^{\texttt{A}}$ somehow, and we have already described how $\mathcal{F}^{\texttt{A}}$ handles random oracle queries made by $\texttt{A}$: by flipping coins at random and keeping a hash table of the results to maintain consistency with future queries. The forger also has corruption oracle and signing oracle access. We assume that $\mathcal{F}^{\texttt{A}}$ is granted access to a corruption oracle (say, through the $k$-OMDL game challenger), so we only need to describe the signing oracle. 


The signing oracle access granted to $\texttt{A}$ is simulated by $\mathcal{F}^{\texttt{A}}$ through backpatching in the following way. $\mathcal{F}^{\texttt{A}}$ selects $c_{\ell+1}$ at random without knowing the corresponding query to $\mathcal{H}^s$. $\mathcal{F}^{\texttt{A}}$ uses the query results $\underline{h}$ to get each $c_{i+1}$ and stores the results in a hash table for consistency in later queries. $\mathcal{F}^{\texttt{A}}$ finally computes $c_\ell$, $\mathcal{F}^{\texttt{A}}$ and can compute the group points $L_\ell, R_\ell$ such that $c_{\ell+1} = \mathcal{H}^s(\underline{\textbf{pk}} \mid \mid m \mid \mid L_\ell \mid \mid R_\ell)$. $\mathcal{F}^{\texttt{A}}$ back-patches the hash table.


\subsection{Playing k-OMDL}

We now construct a master algorithm $\texttt{M}$ that plays the $k$-OMDL game for $k=2d\cdot q_c + d-1$ that operates in the following way.
\begin{enumerate}

\item $\texttt{M}$ receives group parameters $(p, \mathbb{G}, G)$ and target group elements $G_1, \ldots, G_{k+1}$ from the $k$-OMDL challenger.

\item $\texttt{M}$ sets $\textbf{pk}_i := (G_{d(i-1) + 1}, G_{d(i-1) + 2}, \ldots, G_{di})$ for $i=1, \ldots, \frac{k+1}{d}$ and uses $\left\{\textbf{pk}_i\right\}_{i=1}^{\frac{k+1}{d}}$ as input for $\mathcal{F}^{\texttt{A}}$, responding to queries made by $\mathcal{F}^{\texttt{A}}$ for a key $\textbf{pk}_i$ by querying $\mathcal{CO}$ directly with each coordinate and responding with the result.

\item If $\mathcal{F}^{\texttt{A}}$ outputs $\bot$, so does $\texttt{M}$ and $\texttt{M}$ terminates.

\item Otherwise, $\mathcal{F}^{\texttt{A}}$ succeeds executing $\texttt{A}$ twice, each time taking no more than $q_c$ queries to corrupt $d$-dimensional keys, resulting in no more than $2\cdot d\cdot q_c$ queries to the discrete logarithm oracle $\mathcal{CO}$. $\mathcal{F}^{\texttt{A}}$ produces $(\textit{idx}, y_1, \underline{h}, y_2, \underline{h}^\prime)$ where $y_1 = (m_1, \textbf{pk}^{\prime}_1, \sigma_1, \mathfrak{T}_1)$ and $y_2 = (m_2, \textbf{pk}^{\prime}_2, \sigma_2, \mathfrak{T}_2)$ are forgeries using oracle queries $\underline{h}$ and $\underline{h}^\prime$, respectively, and $\textit{idx} = (i^*, j^*)$ as described previously. The messages and rings are identical in these forgeries because they must have been selected before the first challenge query, except with negligible probability. So $\texttt{M}$ can parse 
\begin{align*}
y_1 =& (m, \underline{\textbf{pk}}^\prime, \sigma_1, \mathfrak{T}_1) & \sigma_1 =& (c_1, s_1, \ldots, s_n, \left\{\mathfrak{D}_j\right\}_j) \\
y_2 =& (m, \underline{\textbf{pk}}^\prime, \sigma_2, \mathfrak{T}_2) & \sigma_2 =& (c_1^\prime, s_1^\prime, \ldots, s_n^\prime, \left\{\mathfrak{D}_j^\prime\right\}_j)\end{align*}


\item In the transcript of $\mathcal{F}^{\texttt{A}}$, $\texttt{M}$ finds $c_{i^*+1} = h_{j^*}$ and in the second transcript $c_{i^*+1} = h^\prime_{j^*}$ for some $h_{j^*} \neq h^\prime_{j^*}$. In both transcripts, $c_{i^*+1}$ is the response to the query $\mathcal{H}^s(\textbf{X} \mid \mid m \mid \mid L \mid \mid R)$ for the same group elements $L, R$. Moreover, since this is the query for $c_{i^*+1}$ in both transcripts, the  $\texttt{M}$ finds that $L = s_{i^*} G + c_{i^*} W$ where $W = \mu_X X_{i^*} + \sum_j \mu_j Z_{i^*, j}$ in the first transcript and that $L = s_{i^*}^\prime G + c_{i^*}^\prime W$ in the second transcript, where $L$ and $W$ are common to both transcripts.

\item If $\mu_X = 0$ then $\texttt{M}$ outputs $\bot$ and terminates.

\item Otherwise, $\texttt{M}$ computes the discrete logarithm
$w = \frac{s_{i^*}^\prime - s_{i^*}}{(c_{i^*} - c_{i^*}^\prime)}$ without querying $\mathcal{CO}$.

\item $\texttt{M}$ makes up to $d-1$ queries to $\mathcal{CO}$ to find the discrete logarithms of the elements of any $(d-1)$-subset of $\left\{X_{i^*}, Z_{i^*, 1}, \ldots, Z_{i^*, d-1}\right\}$.

\item $\texttt{M}$ uses $w$ to solve for the final discrete logarithm. 

\item $\texttt{M}$ outputs the $2 \cdot d \cdot q_c$ queries made by $\mathcal{F}^{\texttt{A}}$ and outputs the vector $(x_{i^*}, z_{i^*, 1}, \ldots, z_{i^*, d-1})$.

\end{enumerate}

Note that if $\texttt{M}$ does not terminate and output $\bot$, then $\texttt{M}$ makes up to $2\cdot d \cdot q_c$ queries to $\mathcal{CO}$ for $\mathcal{F}^{\texttt{A}}$ and makes an an additional $d-1$ queries to $\mathcal{CO}$, and yet produces as output $d \cdot (q_c + 1) > d \cdot q_c + d-1$ discrete logarithms, i.e.\ $\texttt{M}$ successfully plays the $k$-OMDL game for $k = 2\cdot d\cdot q_c + d-1$. Furthermore,  if $\texttt{M}$ already corrupted these discrete logarithms, even fewer queries could be made, tightening $k$ and making $\texttt{M}$ a more powerful solver. 

Also note that, as previously mentioned, since the map $(x, z_1, \ldots, z_{d-1}) \mapsto w$ is collision resistant, $\texttt{M}$ can skip steps and guess $w$ in step $7$ only with negligible success.

We previously noted that if $\texttt{A}$ runs in time $O(t)$, $\mathcal{F}^{\texttt{A}}$ runs in time $O(2t)$. $\texttt{M}$ takes an additional  time $s$ due to: simulating oracle queries with coin flips and hash table modifications throughout the execution, constructing keys in step $2$,  making termination checks in steps $3$, $6$, parsing the transcripts in step $4$, retrieving $L$ and $W$ from the transcript in step $5$, computing the discrete logarithm $w$ in step $7$, computing the $d$-linear system of equations in step $9$.

\subsection{Security proof}

All that remains to prove the unforgeability of the $d$-CLSAG scheme from Section \ref{sec:implem} is to show that $\texttt{M}$ as described has a non-negligible acceptance probability.

\begin{theorem}
Let $d, q_h, q_c, q_s \in \mathbb{N}$  and let $(p,\mathbb{G},G)$ be some group parameters. If a $(t, \epsilon, q_h, q_c, q_s, n(-))$-forger of the $d$-CLSAG implementation in Section \ref{sec:implem} exists then a $(2t, \epsilon^\prime)$-solver of the $k$-OMDL problem in $\mathbb{G}$ exists for $k = d\cdot q_c + d - 1$ where $\epsilon^\prime \geq \epsilon\left(\frac{\epsilon}{q_c} - \frac{1}{2^\eta}\right) - p^{-1}$.
\end{theorem}

\begin{proof}
Let where $d, q_h, q_c, q_s$ satisfy the hypotheses and let $\texttt{A}$ be a $(t, \epsilon, q_h, q_c, q_s, n)$-forger of the $d$-CLSAG scheme of Section \ref{sec:implem}, let $\mathcal{F}^{\texttt{A}}$ be the forking algorithm for $\texttt{A}$, and let $\texttt{M}$ be the master algorithm previously described. $\texttt{M}$ terminates and outputs $\bot$ in steps $3$ and $6$ only; otherwise, $\texttt{M}$ succeeds at the $k$-OMDL game. Hence, if $E_3$ is the event that $\texttt{M}$ outputs $\bot$ in step $3$ and $E_6$ is the event that $\texttt{M}$ outptus $\bot$ in step $6$, then $E_3, E_6$ are disjoint and the acceptance probability for $\texttt{M}$ is $1 - \mathbb{P}(E_3 \cup E_6) =  1 - \mathbb{P}(E_3) - \mathbb{P}(E_6)$. The probability that $\texttt{M}$ outputs $\bot$ in step $6$ is the probability that the hashed coefficient $\mu_X = 0$, which occurs with probability $p^{-1}$.  $\texttt{M}$ outputs $\bot$ in step $3$ when $\mathcal{F}^{\texttt{A}}$ produces $\bot$, but the forking lemma gives us that the acceptance probability of $\mathcal{F}^\texttt{A}$ is bounded from below by $\epsilon\left(\frac{\epsilon}{q_c} - \frac{1}{2^\eta}\right)$. Hence, $\texttt{M}$ succeeds with probability at least $ \left(\epsilon\left(\frac{\epsilon}{q_c} - \frac{1}{2^\eta}\right) - p^{-1}\right)$.
\end{proof}



\section{Security: Signer ambiguity}


\subsection{Hardness}

We show our scheme is computationally signer-ambiguous if the following DDH game is hard in $\mathbb{G}$.

\begin{defn}[Decisional Diffie-Hellman]\label{ddhgame} Let $\texttt{A}$ be any PPT algorithm, $(p, \mathbb{G}, G)$ and let $n \in \mathbb{N}$.
\begin{enumerate}
\item The challenger selects $(r_{i,1}, r_{i,2}, r_{i,3}) \left(\mathbb{Z}/p\mathbb{Z}\right)^3$ uniformly and independently for $i=1, \ldots, n$. The challenger computes the public keys $R_{i,1} = r_{i,1} G$, $R_{i,2} = r_{i,2}G$, $R_{i,3}^{(0)} = r_{i,1} r_{i,2} G$, $R_{i,3}^{(1)} = r_{i,3} G$.

\item The challenger selects a bit $b$ independently and uniformly from $\left\{0,1\right\}$ and sends $\left\{(R_{i,1}, R_{i,2}, R_{i,3}^{(b)})\right\}_{i=1}^{n}$ to $\texttt{A}$.

\item $\texttt{A}$ outputs a bit $b^\prime$, succeeding if $b = b^\prime$.
\end{enumerate}

Note any algorithm can flip a coin and guess correctly half the time. We say the \textit{advantage} of $\texttt{A}$ is the difference between the probability of success for $\texttt{A}$ and $1/2$. If $\texttt{A}$ can solve this with an advantage at least $\epsilon$ in time at most $t$, we say $\texttt{A}$ is a $(t,\epsilon)$-solver of the DDH problem in $\mathbb{G}$. 

\end{defn}


We note that due to the random self-reducibility of the DDH game, the classic DDH game is no harder than Definition \ref{ddhgame}
\subsection{Defining signer ambiguity}

\begin{defn}\label{sigambgame} We say $\texttt{A}$ is a $(t,\epsilon,n_1,n_2)$-solver of the signer ambiguity game if it can succeed with non-negligible advantage at the following game.
\begin{enumerate}
\item The challenger selects $n_1$ secret keys $\left\{\textbf{sk}_i\right\} \subseteq (\mathbb{Z}/p\mathbb{Z})^d$, computes the corresponding public keys $\textbf{pk}_i = \textbf{sk}_i \circ \textbf{G}$, and sends $\left\{\textbf{pk}_i\right\}$ to $\texttt{A}$.

\item $\texttt{A}$ outputs an arbitrary message $m$ and a ring of $n_2$ distinct members $\underline{\textbf{pk}}^\prime \subseteq \left\{\textbf{pk}_i\right\}$.

\item The challenger selects a ring index $1 \leq \ell \leq n_2$ uniformly at random, retrieves the private key $\textbf{sk}$, and sends a valid signature-tag pair $(\sigma, \mathfrak{T}) \leftarrow \texttt{Sign}(m, \underline{\textbf{pk}}^\prime, \textbf{sk})$ to $\texttt{A}$.
\item $\texttt{A}$ outputs an index $\ell^\prime$, succeeding if $\ell = \ell^\prime$. 
\end{enumerate}
Note that a simulator in place of $\texttt{A}$ without any input can guess any index from $\left\{1, \ldots, n_2\right\}$ with coin flips, succeeding with probability  at least $1/n_2$. We define the advantage of $\texttt{A}$ as the difference in acceptance probability and $1/n_2$.
\end{defn}

Note that if the secret index $\ell$ is leaked in the signer ambiguity game, this is equivalent to leaking information about the bit $b$ used in the DDH game. Also note that the game could be generalized to allow $\texttt{A}$ repeated and adaptive access to a signing oracle, just so long as so-called \textit{ring intersection} attacks are taken into account when defining the advantage of $\texttt{A}$. However, such a generalization is equivalent to ours.

\subsection{Security proof}

If $\mathbb{G}$ satisfies the DDH hardness assumption, then the distribution of the triple $(r_1G, r_2G, r_3G)$ is computationally indistinguishable from the triple $(r_1G, r_2G, r_1r_2G)$,  where the $r_i$ are independently uniform on $\mathbb{Z}/p\mathbb{Z}$. If $\mathcal{H}^p: \left\{0,1\right\}^* \to \mathbb{G}$ is modeled as a random oracle with output that is independent of its input, the distribution of a tuple $(r_1G, r_2G, r_3G)$ is identical to the distribution of $(r_1G, \mathcal{H}^p(r_1G), r_3G)$ where $r_1, r_3$ are independently uniform on $\mathbb{Z}/p\mathbb{Z}$. Hence, under the random oracle model and assuming $\mathbb{G}$ is DDH-hard, the distribution of triples $(r_1G, \mathcal{H}^p(r_1G), r_1\mathcal{H}^p(r_1G))$ where $r_1$ is uniformly random from $\mathbb{Z}/p\mathbb{Z}$ is computationally indistinguishable from the distribution of triples $(r_1G, \mathcal{H}^p(r_1G), r_3G)$ where $r_1, r_3$ are uniformly random from $\mathbb{Z}/p\mathbb{Z}$.
  
  

Now note that a solver of the signer ambiguity game is given $X_i$ and $\mathcal{H}^p(X_i)$ for each ring member and the linkability tag $\mathfrak{T} = x_\ell \mathcal{H}^p(X_\ell)$. The solver with a non-negligible advantage at guessing $\ell$ has a non-negligible advantage in distinguishing whether a given triple $(X_i, \mathcal{H}^p(X_i), \mathfrak{T})$ satisfies $\mathfrak{T} = x_i \mathcal{H}^p(X_i)$ or not.

\begin{theorem}
If a $(t, \epsilon, n_1, n_2)$-solver of the signer-ambiguity game exists, there exists a $(t, \frac{\epsilon}{2})$-solver of the DDH game. 
\end{theorem}

\begin{proof}
We assume $\texttt{A}$ is an algorithm that can succeed at the game in Definition \ref{sigambgame} with non-negligible advantage. We construct a master algorithm $\texttt{M}$ that plays the game in Definition \ref{ddhgame} by executing $\texttt{A}$ in a black box such that $\texttt{M}$ plays the role of the challenger in Definition \ref{sigambgame}. 

$\texttt{M}$ receives a set of DDH challenge tuples $\left\{(R_{i,1}, R_{i,2}, R_{i,3}^{(b)})\right\}_{i=1}^{n}$. $\texttt{M}$ keeps two internal hash tables to maintain consistency between oracle queries made to $\mathcal{H}^p$ and $\mathcal{H}^s$, and flips coins to determine hash outcomes except as specified below. $\texttt{M}$ sets $X_i := R_{i,1}$, backpatches the key image basepoints $\mathcal{H}^p(X_i) := R_{i,2}$, and sets the purported key images $\mathfrak{T}_i := R_{i,3}^{(b)}$. The algorithm selects $Z_{i,j}$ at random and sets $\textbf{pk}_i := (X_i, Z_{i,1}, \ldots, Z_{i,d-1})$. The algorithm $\texttt{M}$ then operates in the following way:
\begin{enumerate}
\item $\texttt{M}$ sends the public keys $\underline{\textbf{pk}} = \left\{\textbf{pk}_i\right\}_{i=1}^{n}$ to $\texttt{A}$. 

\item $\texttt{A}$ outputs a message $m$ and a ring $\underline{\textbf{pk}}^\prime$. 

\item If $\underline{\textbf{pk}}^\prime \not\subseteq \underline{\textbf{pk}}$, $\texttt{M}$ outputs $\bot$ and terminates. Otherwise, the algorithm $\texttt{M}$ can find a one-to-one correspondence between ring indices in $\underline{\textbf{pk}}^\prime$ and key indices in $\underline{\textbf{pk}}$, so that for each ring index $1 \leq \ell \leq n_2$ in $\underline{\textbf{pk}}^\prime$, there exists some key index $1 \leq i(\ell) \leq n_1$ in $\underline{\textbf{pk}}$ such that the ring member is $X_{i(\ell)} = R_{i(\ell),1}$, has key image basepoint $\mathcal{H}^p(X_{i(\ell)}) = R_{i(\ell),2}$, and has key image $R_{i(\ell),3}^b$. 

\item $\texttt{M}$ simulates a signature in the following way.
\begin{enumerate}[(a)]
\item $\texttt{M}$ selects a random index $1 \leq \ell \leq n_2$, selects a random scalar $c_{\ell+1} \in \mathbb{Z}/p\mathbb{Z}$, and selects random scalars $s_1, s_2, \ldots, s_n \in \mathbb{Z}/p\mathbb{Z}$.

\item For $i=\ell+1, \ell+2, \ldots, n-1, n, 1, 2, \ldots, \ell-1$, $\texttt{M}$ computes 
\begin{align*}
L_i :=& s_iG + c_i\left(\mu_X X_i + \sum_j \mu_j Z_{i,j}\right) \\
R_i :=& s_i\mathcal{H}^p(X_i) + c_i\left(\mu_X \mathfrak{T}_{i(\ell)} + \sum_j \mu_j \mathfrak{D}_j\right)\\
c_{i+1} :=& \mathcal{H}^s\left(\underline{\textbf{pk}}^\prime \mid \mid m \mid \mid L_i \mid \mid R_i \right)
\end{align*}

\item $\texttt{M}$ computes $c_\ell$, $L_\ell$, and $R_\ell$ as above. If $\mathcal{H}^s$ has been queried before with $\left(\underline{\textbf{pk}}^\prime \mid \mid m \mid \mid L_\ell \mid \mid R_\ell \right)$, $\texttt{M}$ outputs $\bot$ and terminates. Otherwise, $\texttt{M}$ backpatches $\mathcal{H}^s\left(\underline{\textbf{pk}}^\prime \mid \mid m \mid \mid L_\ell \mid \mid R_\ell \right) \leftarrow c_{\ell+1}$.

\item $\texttt{M}$ sends to $\texttt{A}$ the signature-tag pair $\left(\sigma, \mathfrak{T}_{i(\ell)}\right)$ where $\sigma = (c_1, s_1, \ldots, s_n, \left\{\mathfrak{D}_j\right\}_j)$.


\end{enumerate}

\item $\texttt{A}$ outputs a signing index $\ell^\prime$. If $\ell = \ell^\prime$, $\texttt{M}$ outputs $b^\prime = 0$. Otherwise, $\texttt{M}$ flips a coin and outputs a bit $b^\prime$ selected uniformly at random.
\end{enumerate}

Note that $\texttt{M}$ only terminates and outputs $\bot$ if $\texttt{A}$ asks for a signature with a ring containing a key that is not a DDH challenge key or if $\mathcal{H}^s$ has been queried with $\left(\underline{\textbf{pk}}^\prime \mid \mid m \mid \mid L_\ell \mid \mid R_\ell \right)$ before step $4c$. We can assume $\texttt{A}$ never asks for a signature with a bad ring like this. Moreover, the points $L_\ell$ and $R_\ell$ are uniformly distributed, so the probability that any algorithm can guess the input for backpatching is negligible. Hence, $\texttt{M}$ carries out the game in Definition \ref{ddhgame} except with negligible probability.

The law of total probability gives us that $\mathbb{P}\left[\texttt{M}\text{ wins}\right] = \frac{1}{2}\mathbb{P}\left[1 \leftarrow \texttt{M} \mid b=1\right] + \frac{1}{2}\mathbb{P}\left[0 \leftarrow \texttt{M} \mid b=0\right]$. Moreover, the event that $1 \leftarrow \texttt{M}$ is exactly the event that $\ell^\prime \leftarrow \texttt{A}$ and $\ell^\prime \neq \ell$, and the event that $0 \leftarrow \texttt{M}$ is exactly the event that $\ell^\prime \leftarrow \texttt{A}$ and $\ell^\prime = \ell$. If $b=1$, then $\texttt{M}$ received random points, not the DDH exchange key, so the signature sent to $\texttt{A}$ consists of uniformly random points and scalars. $\texttt{A}$ can do no better than to guess the index $\ell^\prime$ uniformly at random.  So $\mathbb{P}\left[1 \leftarrow \texttt{M} \mid b=1\right] = \mathbb{P}\left[\ell^\prime \leftarrow \texttt{A}, \ell^\prime \neq \ell \mid b = 1\right] = \frac{n-1}{n}$. On the other hand, if $b = 0$, then $\texttt{M}$ received the DDH exchange key. In this case, $\texttt{A}$ has an advantage $\epsilon$ at guessing the successful index, so $\mathbb{P}\left[\ell^\prime \leftarrow \texttt{A}, \ell = \ell^\prime \mid b = 0\right] = \frac{1}{n} + \epsilon$. Hence, $\texttt{M}$ succeeds at the DDH game with probability $\frac{1}{2}\left(1-\frac{1}{n}\right) + \frac{1}{2}\left(\frac{1}{n} + \epsilon\right) = \frac{1}{2} + \frac{\epsilon}{2}$.
\end{proof}

\bibliographystyle{plain}
\bibliography{bibliography}

\end{document}
